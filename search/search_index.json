{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ISCC - Content Codes # A Proposal for a Modern and Open Content-Based Identifier # The ISCC is... # a universal identifier for all kinds of digital content (text, image, audio, video) a lightweight and similarity-preserving fingerprint designed for cross-sector applicability (journalism, books, music, film, etc.) designed to identify content in decentralized and networked environments and most importantly it is free, open-source and transparent You want to try an early prototype instantly? Head over to an interactive demo Update The ISCC has been accepted by ISO as full work item ISO/AWI 24138 - International Standard Content Code and is being standardized at TC 46/SC 9/WG 18 . Current development is documented at ISCC - Codec & Algorithms Motivation # Increasing amounts of dynamic, short-lived, and granular content need to be managed and require new and innovative tools. A crucial prerequisite for content-related transactions to succeed in this new and demanding environment is the capability to address and identify content efficiently. Yet many industries that deal with digital content do not even have standard identifiers. There is no existing solution for those industries that deal with short-lived or granular content such as journalism. There is also no widely adopted standardized identifier for digital images. The overhead and cost of manually assigning and tracking identifiers for such content are prohibitive. But there is a solution to the problem: auto-generated identifiers created algorithmically from the content itself. With the advent of blockchain technology, the Internet is moving towards a network of peer-to-peer transactions. In a multi-sided ecosystem, anybody may have a legitimate interest to generate, lookup, or register an identifier for some digital content \u2013 whether they own the content or not. Authorship or copyright is not a requirement to create or use an identifier. But an identifier is a requirement to communicate and agree on authorship, origin, copyright, and other information. Technology allows us to authoritatively map identifiers to digital content using open, standardized fingerprinting algorithms. Open and accessible standard identifiers, designed to manage small and sometimes transient pieces of digital content are fundamental for transactions and sales activities in our increasingly heterogeneous media environment. By using standardized, decentralized, algorithmic identifiers for digital content, all ecosystem participants can engage more efficiently in content-related transactions. Key Features and Differentiators # Decentralized issuance through algorithmic creation Generic content identification (text, images, audio, video) Algorithmic similarity detection and deduplication Low management costs Low barrier of entry Designed for blockchain based registration How it works # ISCC identifiers are generated algorithmically from the content itself . Content files are processed to build the identifier. The ISCC does not have to be manually assigned, neither does it have to be carried around or embedded within the content. The content itself is the source and authority of the ISCC Code . The ISCC Code is a unique, hierarchically structured, composite identifier. It is built from a generic and balanced mix of content-derived, locality-sensitive and similarity-preserving hashes generated from metadata and content. The latest version of these pages can be found at iscc.codes","title":"Overview"},{"location":"#iscc-content-codes","text":"","title":"ISCC - Content Codes"},{"location":"#a-proposal-for-a-modern-and-open-content-based-identifier","text":"","title":"A Proposal for a Modern and Open Content-Based Identifier"},{"location":"#the-iscc-is","text":"a universal identifier for all kinds of digital content (text, image, audio, video) a lightweight and similarity-preserving fingerprint designed for cross-sector applicability (journalism, books, music, film, etc.) designed to identify content in decentralized and networked environments and most importantly it is free, open-source and transparent You want to try an early prototype instantly? Head over to an interactive demo Update The ISCC has been accepted by ISO as full work item ISO/AWI 24138 - International Standard Content Code and is being standardized at TC 46/SC 9/WG 18 . Current development is documented at ISCC - Codec & Algorithms","title":"The ISCC is..."},{"location":"#motivation","text":"Increasing amounts of dynamic, short-lived, and granular content need to be managed and require new and innovative tools. A crucial prerequisite for content-related transactions to succeed in this new and demanding environment is the capability to address and identify content efficiently. Yet many industries that deal with digital content do not even have standard identifiers. There is no existing solution for those industries that deal with short-lived or granular content such as journalism. There is also no widely adopted standardized identifier for digital images. The overhead and cost of manually assigning and tracking identifiers for such content are prohibitive. But there is a solution to the problem: auto-generated identifiers created algorithmically from the content itself. With the advent of blockchain technology, the Internet is moving towards a network of peer-to-peer transactions. In a multi-sided ecosystem, anybody may have a legitimate interest to generate, lookup, or register an identifier for some digital content \u2013 whether they own the content or not. Authorship or copyright is not a requirement to create or use an identifier. But an identifier is a requirement to communicate and agree on authorship, origin, copyright, and other information. Technology allows us to authoritatively map identifiers to digital content using open, standardized fingerprinting algorithms. Open and accessible standard identifiers, designed to manage small and sometimes transient pieces of digital content are fundamental for transactions and sales activities in our increasingly heterogeneous media environment. By using standardized, decentralized, algorithmic identifiers for digital content, all ecosystem participants can engage more efficiently in content-related transactions.","title":"Motivation"},{"location":"#key-features-and-differentiators","text":"Decentralized issuance through algorithmic creation Generic content identification (text, images, audio, video) Algorithmic similarity detection and deduplication Low management costs Low barrier of entry Designed for blockchain based registration","title":"Key Features and Differentiators"},{"location":"#how-it-works","text":"ISCC identifiers are generated algorithmically from the content itself . Content files are processed to build the identifier. The ISCC does not have to be manually assigned, neither does it have to be carried around or embedded within the content. The content itself is the source and authority of the ISCC Code . The ISCC Code is a unique, hierarchically structured, composite identifier. It is built from a generic and balanced mix of content-derived, locality-sensitive and similarity-preserving hashes generated from metadata and content. The latest version of these pages can be found at iscc.codes","title":"How it works"},{"location":"concept/","text":"ISCC - Concept # The internet is shifting towards a network of decentralized peer-to-peer transactions. If we want our transactions on the emerging blockchain networks to be about content we need standardized ways to address content. Our transactions might be payments, attributions, reputation, certification, licenses or entirely new kinds of value transfer. All this will happen much faster and easier if we, as a community, can agree on how to identify content in a decentralized environment. This is the higher level concept of an open proposal to the wider content community for a common content identifier. We would like to share our ideas and spark a conversation with journalists, news agencies, content creators, publishers, distributors, libraries, musicians, scientists, developers, lawyers, rights organizations and all the other participants of the content ecosystem. Introduction # The structure and management of global identifiers strongly correlates with the grade of achievable automation and the potential for innovation within and across different sectors of the media industries. There are many existing standards for media identifiers serving a wide array of use cases. Book publishing uses the ISBN , magazines and journals have the ISSN , music industry has ISRC and ISWC and film has ISAN and EIDR \u2013 each of them serving a set of specific purposes. On the other side of the spectrum there are also generic identifiers standards such as the DOI , ITU HANDLE , URN , ARK . The DOI, for example, can be used to identify any digital, physical or abstract object . All these identifiers have important and distinct roles across different industries and use cases. The most substantial differentiator of the ISCC is the fact that it is algorithmically bound to the digital content it identifies. Other standards require human intervention to assign and track the mapping between identifier and object (binding). Many of those standards focus on how to resolve an identifier to some network location where metadata or the object itself can be found. The ISCC inverts this principle . It gives an answer to the question: \"Given some digital content, how can I find its identifier to reference the content in a transaction?\". This means that the ISCC for any digital content can be found (generated) from the content itself, without the need to involve any third-party. As such the ISCC fulfills a distinct role and is not a replacement for established identifiers . Rather it is designed as an umbrella standard to augment established identifiers with enhanced algorithmic features. It can be used in the metadata of existing standards or support discoverability (reverse lookup). Many of the established systems are based on centralized or hierarchical registries that involve manual and costly management processes. To sustain such systems the costs have to be recouped by fees for identifier assignment, metadata storage or paid access to metadata which inhibits accessibility and discoverability. The overhead, cost and general properties of these systems make them prohibitive for many innovative use cases that require a more informal and generic identifier assignment (eg. granular content). Communities with short lived or user generated content, don't have any agreed-upon global identifiers for their content. The fast paced development of the digital media economy has led to an increasing fragmentation of identifiers and new barriers in interoperability. For example major e-book retailers do not require an ISBN and instead established their own proprietary identifiers. Amazon has the ASIN , Apple has Apple-ID and Google has GKEY . For many tasks current systems need to track and match all the different vendor specific IDs, which is an inefficient and error prone process. Resolving an ISCC to a network location, metadata or the content itself can be accomplished with neutral and decentralized blockchain-based registries that don't require a centralized or hierarchical system to manage, track and store unique identifiers, ownership assignments, associated metadata and other information. Advances in data structures, algorithms, machine learning and the emergence of crypto economics allows us to invent new kinds of media identifiers and re-imagine existing identifiers with innovative use cases in mind. Blockchains and Smart Contracts offer great opportunities in solving many of the challenges of identifier registration, like centralized management, data duplication and disambiguation, vendor lock-in and long term data retention. This is an open proposal to the digital media community and explores the possibilities of a decentralized content identifier system. We\u2019d like to establish an open standard for persistent, unique, vendor independent and content derived cross-media identifiers that can be stored and managed on global, public and decentralized blockchains. We envision a self-governing ecosystem with a low barrier of entry where commercial and non-commercial initiatives can both innovate and thrive next to each other. Media Identifiers for Blockchains # Media cataloging systems tend to get out of hand and become complex and often unmanageable. Our design proposal is focused on keeping the ISCC system as simple and more importantly as automatable as possible, while maximizing practical value for the most important use cases \u2014 meaning you should get out more than you have to put in. With this in mind we come to the following basic design decisions: A \u201cMeaningful\u201d Identifier # In traditional database systems it is recommended practice to work with surrogate keys as identifiers. A surrogate key is a dumb number and has no business meaning and is completely decoupled from the data it identifies. Uniqueness of such identifiers is guaranteed either via centralized incremental assignment by the database system or via random UUIDs which have a very low probability of collisions. While random UUIDs could be generated in a decentralized way, both approaches require some external authority that establishes or certifies the linkage between the identifier and the associated metadata and content. This is why we decided to go with a \u201cmeaningful\u201d content and metadata derived identifier (CMDI) . Anyone will be able to verify that a specific identifier indeed belongs to a given digital content. Even better, anyone can \u201cfind\u201d the identifier for a given content without the need to consult external data sources. This approach also captures essential information about the media in the identifier itself, which is very useful in scenarios of machine learning and data analytics. A Decentralized Identifier # The ISCC is designed to be registry agnostic. This means that content identification codes can be self-issued in a decentralized and parallel fashion without the need for governance by a centralized registration agency. Without registration an ISCC is owned by the content and not by a person or organization. An unregistered ISCC is useful in cases where multiple independent parties exchange information about content. The CMDI approach is helpful with common issues like data integrity, validation, de-duplication and disambiguation. Systems that process digital content can integrate ISCC support and benefit immediately. The integrator does not depend on all third-parties having to assign, track and deliver ISCC codes, because those can be generated from the content itself. ISCC registration becomes necessary when an ISCC code needs to be globally unique, publicly discoverable, resolvable, owned or authenticated . While these features inevitably require some kind of registry, not all of them require a centralized institutional registry. In a centralized system the central authority is in control of the issuance of identifiers and safeguards various requirements like identifier uniqueness or ownership. In a decentralized system where everybody can register an identifier we need a different approach. The ISCC will specify the necessary protocols to implement the aforementioned features in a decentralized, federated environment and across multiple public blockchains. Given a registered ISCC code, an application can unambiguously determine on what blockchain (if any), by which account, and at what time an ISCC has been registered. Registered ISCC codes have to indicate an authoritative public blockchain network. This indicator is part of the ISCC Code itself, such that codes registered on different networks cannot collide. This guarantees uniqueness of ISCC codes across multiple blockchains. Ownership of ISCC codes (not the identified content) is granted to the signatory of the first transaction for a given ISCC code on the corresponding blockchain. Global uniqueness of ISCC codes is accomplished by the blockchain indicator in combination with a client side counter. Registration clients first check for a prior registration of a given ISCC code on a given blockchain. If the ISCC code is already registered by another account the client may simply increments a suffix of the code before registration. Applications are instructed to ignore duplicate registrations of identical codes that occur on a blockchain after an initial registration. This approach retains global clustering and de-duplication features while at the same time offering owned , authenticated and globally unique ISCC codes. The model also allows for verifiable transfers of ISCC ownership. Given an appropriate protocol it is even possible to switch the authoritative blockchain for an ISCC after initial registration without changing the ISCC code itself. Registration Services # Registration services offer a plethora of valuable and indispensable benefits. Every industry has its special requirements. Ultimately the stakeholders from those industries will have to set the rules for data curation, metadata management and administrative control. A Blockchain is a low level backend infrastructure. And while blockchains might make access to identifiers and metadata more accessible, there is still cost involved with storing data, running the infrastructure and providing middleware and frontends. Blockchains work as incentive based economic systems. Registrars can offer commercially viable value added services on top of the lower level blockchain networks. For example: Identity verification of registrants Certification/attestation of registry entries Data curation and indexing services Blockchain key-management services Custodial blockchain account management Middleware and front-end applications Infrastructure operations Participation in blockchain network governance Storage Considerations # On a typical public blockchain all data is fully replicated among participants. This allows for independent and autonomous validation of transactions. All blockchain data is highly available, immutable, tamper-proof, timestamped and in most cases openly accessible. However, under high load the limited transaction capacity (storage space per unit of time) creates a transaction fee market for on-chain data. This leads to growing transaction costs and makes storage a scarce and increasingly precious resource on public decentralized blockchains. For example storing a 46 character identifier on the Ethereum blockchain in July 2019 cost ~ $0.50. So it is mandatory for our identifier and its eventual metadata schema to be very space efficient to maximize benefit at minimal cost. The basic metadata that will be required to generate and register identifiers must be: minimal in scope clearly specified robust against human error enforced on technical level adequate for public use (no legal or privacy issues) Layers of Digital Media Identification # While we examined existing identifiers we discovered that there is often much confusion about the extent or coverage of what exactly is being identified by a given system. With our idea for a generic cross-media identifier we want to put special weight on being precise with our definitions and found it helpful to distinguish between \u201cdifferent layers of digital media identification\". We found that these layers exist naturally on a scale from abstract to concrete. Our analysis also showed that existing standard identifiers operate on one or at most two of such layers. The ISCC is designed as a composite identifier that takes the different layers of media identification into consideration: Layer 1 \u2013 Abstract Creation # In the first and most abstract layer we are concerned with distinguishing between different works or creations in the broadest possible sense . The scope of identification is completely independent of any manifestations of the work, be it physical or digital in nature. It is also agnostic to creators, rights holders or any specific interpretations, expressions or language versions of a work. It only relates to the intangible creation - the idea itself. Layer 2 \u2013 Semantic Field # This layer relates to the meaning or essence of a work. It is an amorphous collection or combination of facts, concepts, categories, subjects, topics, themes, assumptions, observations, conclusions, beliefs and other intangible things that the content conveys. The scope of identification is a set of coordinates within a finite and multidimensional semantic space. Layer 3 \u2013 Generic Manifestation # In this layer we are concerned with the literal structure of a media type specific and normalized manifestation. Namely the basic text, image, audio or video content independent of its semantic meaning or media file encoding and with a tolerance to variation. This \"tolerance to variation\" bundles a set of different versions with corrections, revisions, edits, updates, personalization, different format encodings or data compression of the same content under one grouping identifier. A generic manifestation is independent of a final digital media product and is specific to an expression, version or interpretation of a work. Unfortunately it is not obvious where generic manifestation of a work ends and another one starts. It depends on human interpretation and context. How much editing do we allow before we call it a \u201cdifferent\u201d manifestation and give it a different identifier. A practical but only partial solution to this problem is to create an algorithmically defined and testable spectrum of tolerance to variation per media type. This can provide a stable and repeatable process to distinguish between generic content manifestations. But it is important to understand that such a process is not expected to yield results that are always intuitive to human expectations as to where exactly boundaries should be. Layer 4 \u2013 Media Specific Manifestation # This layer relates to a manifestation with a specific encoding . It identifies a data-file encoded and offered in a specific media format including a tolerance to variation to account for minor edits and updates within a format without creating a new identifier. For example, one could distinguish between the PDF, DOCX or WEBSITE versions of the same content as generated from a single source publishing system. This layer does only distinguish between products or \"artifacts\" with a given packaging or encoding. Layer 5 \u2013 Exact Representation # In this layer we identify a data-file by its exact binary representation without any interpretation of meaning and without any ambiguity. Even a minimal change in data that might not change the interpretation of content would create a different identifier. Like the first four layers, this layer does not express any information related to content location or ownership . Layer 6 \u2013 Individual Copy # In the physical world we would call a specific book (one that you can take out of your shelve) an individual copy . This implies a notion of locality and ownership . In the digital world the semantics of an individual copy are very different. An individual copy might be distinguished by a license you own or by a personalized watermark applied by the retailer at time of sale or some digital annotations you have added to your digital media file. While there can only ever be one exact individual copy of a physical object , there always can be endless replicas of an \"individual copy\" of a digital object . It is very important to keep this difference in mind. Ignoring this fact has caused countless misunderstandings and is the source of confusion throughout the media industry \u2013 especially in the realm of copyright and license discussions. We could try to define an individual digital copy by its location and exact content on a specific physical storage medium (like a DVD, SSD ...). But this does not account for the fact that it is nearly impossible to stop someone from creating an exact replica of that data or at least a snapshot or recording of the presentation of that data on another storage location. And most importantly such a replica does not affect the original data and even less can make it magically disappear. In contrast, if you give your individual copy of your book to someone else, you won't \"have it\" anymore. It is clear, that with digital media this cannot reliably be the case . The only way would be to build a tamper-proof physical device (secure element) that does not reveal the data itself, which would defeat the purpose by making the content itself unavailable. But there are ways to partially simulate such inherently physical properties in the digital world. Most notably with the emergence of blockchain technology it is now possible to have a cryptographically secured and publicly notarized tamper-proof certificate of ownership. This can serve as a record of agreement about ownership of an \u201cindividual copy\u201d. But is does not by itself enforce location or accessibility of the content, nor does it prove the authorization of the certifying party itself or the legal validity of the agreement. Design Principles # As a generic content identifier the ISCC Standard is a an initiative with a broad scope. These are the principles that should guide its design and adoption: Target existing, unsolved, real-world problems Provide a technological and automatable solution Be generic and useful to a broad audience Keep the standard pragmatic and simple to implement Keep it extendable and forward compatible Provide marketable user-facing sample applications Provide machine readable test data for implementers Provide developer tools in different programming languages Promote implementations in different sectors The specification should be open and public Engage with other standards and interested parties Algorithmic Tools # While many details about the ISCC are still up for discussion we are quite confident about some of the general algorithmic families that will make it into the final specification for the identifier. These will play an important role in how we generate the different components of the identifier: Similarity preserving hash functions (Simhash, Minhash ...) Perceptual hashing (pHash, Blockhash, Chromaprint \u2026) Content defined chunking (Rabin-Karp, FastCDC ...) Merkle trees ISCC Proof-of-Concept # Before we settle on the details of the proposed ISCC identifier, we built a simple and reduced proof-of-concept implementation of our ideas. It enables us and other developers to test with real world data and systems and find out early what works and what doesn't. Update An interactive demo of the concept is available at https://isccdemo.content-blockchain.org/ The minimal viable, first iteration ISCC will be a byte structure built from the following components: Meta-Code # The Meta-Code will be generated as a similarity preserving hash from minimal generic metadata like title and creators . It operates on Layer 1 and identifies an intangible creation. It is the first and most generic grouping element of the identifier. We will be experimenting with different n-gram sizes and bit-length to find the practical limits of precision and recall for generic metadata. We will also specify a process to disambiguate unintended collisions by adding optional metadata. Partial Content Flag # The Partial Content Flag is a 1-bit flag that indicates whether the remaining elements relate to the complete work or only to a subset of it. Media Type Flag # The Media Type Flag is a 3 bit flag that allows us to distinguish between up to 8 generic media types (GMTs) to which our Content-Code component applies. We define a generic media type as basic content types such as plain text or raw pixel data that is specified exactly and extracted from more complex file formats or encodings. We start with generic text and image types and add audio, video and mixed types later. Content-Code # The Content-Code operates on Layer 3 and will be a GMT-specific similarity preserving hash generated from extracted content. It identifies the normalized content of a specific GMT, independent of file format or encoding. It relates to the structural essence of the content and groups similar GMT-specific manifestations of the abstract creation or parts of it (as indicated by the Partial Content Flag). For practical reasons we intentionally skip a Layer 2 component at this time. It would add unnecessary complexity for a basic proof-of-concept implementation. Data-Code # The Data-Code operates on Layer 4 and will be a similarity preserving hash generated from shift-resistant content-defined chunks from the raw data of the encoded media blob. It groups complete encoded files with similar content and encoding. This component does not distinguish between GMTs as the files may include multiple different generic media types. Instance-Code # The Instance-Code operates on Layer 5 and will be the top hash of a Merkle tree generated from (potentially content-defined) chunks of raw data of an encoded media blob. It identifies a concrete manifestation and proves the integrity of the full content. We use the Merkle tree structure because it also allows as to verify integrity of partial chunks without having to have the full data available. This will be very useful in any scenarios of distributed data storage. We intentionally skip Layer 6 at this stage as content ownership and location will be handled on the blockchain layer of the stack and not by the ISCC identifier itself.","title":"Concept"},{"location":"concept/#iscc-concept","text":"The internet is shifting towards a network of decentralized peer-to-peer transactions. If we want our transactions on the emerging blockchain networks to be about content we need standardized ways to address content. Our transactions might be payments, attributions, reputation, certification, licenses or entirely new kinds of value transfer. All this will happen much faster and easier if we, as a community, can agree on how to identify content in a decentralized environment. This is the higher level concept of an open proposal to the wider content community for a common content identifier. We would like to share our ideas and spark a conversation with journalists, news agencies, content creators, publishers, distributors, libraries, musicians, scientists, developers, lawyers, rights organizations and all the other participants of the content ecosystem.","title":"ISCC - Concept"},{"location":"concept/#introduction","text":"The structure and management of global identifiers strongly correlates with the grade of achievable automation and the potential for innovation within and across different sectors of the media industries. There are many existing standards for media identifiers serving a wide array of use cases. Book publishing uses the ISBN , magazines and journals have the ISSN , music industry has ISRC and ISWC and film has ISAN and EIDR \u2013 each of them serving a set of specific purposes. On the other side of the spectrum there are also generic identifiers standards such as the DOI , ITU HANDLE , URN , ARK . The DOI, for example, can be used to identify any digital, physical or abstract object . All these identifiers have important and distinct roles across different industries and use cases. The most substantial differentiator of the ISCC is the fact that it is algorithmically bound to the digital content it identifies. Other standards require human intervention to assign and track the mapping between identifier and object (binding). Many of those standards focus on how to resolve an identifier to some network location where metadata or the object itself can be found. The ISCC inverts this principle . It gives an answer to the question: \"Given some digital content, how can I find its identifier to reference the content in a transaction?\". This means that the ISCC for any digital content can be found (generated) from the content itself, without the need to involve any third-party. As such the ISCC fulfills a distinct role and is not a replacement for established identifiers . Rather it is designed as an umbrella standard to augment established identifiers with enhanced algorithmic features. It can be used in the metadata of existing standards or support discoverability (reverse lookup). Many of the established systems are based on centralized or hierarchical registries that involve manual and costly management processes. To sustain such systems the costs have to be recouped by fees for identifier assignment, metadata storage or paid access to metadata which inhibits accessibility and discoverability. The overhead, cost and general properties of these systems make them prohibitive for many innovative use cases that require a more informal and generic identifier assignment (eg. granular content). Communities with short lived or user generated content, don't have any agreed-upon global identifiers for their content. The fast paced development of the digital media economy has led to an increasing fragmentation of identifiers and new barriers in interoperability. For example major e-book retailers do not require an ISBN and instead established their own proprietary identifiers. Amazon has the ASIN , Apple has Apple-ID and Google has GKEY . For many tasks current systems need to track and match all the different vendor specific IDs, which is an inefficient and error prone process. Resolving an ISCC to a network location, metadata or the content itself can be accomplished with neutral and decentralized blockchain-based registries that don't require a centralized or hierarchical system to manage, track and store unique identifiers, ownership assignments, associated metadata and other information. Advances in data structures, algorithms, machine learning and the emergence of crypto economics allows us to invent new kinds of media identifiers and re-imagine existing identifiers with innovative use cases in mind. Blockchains and Smart Contracts offer great opportunities in solving many of the challenges of identifier registration, like centralized management, data duplication and disambiguation, vendor lock-in and long term data retention. This is an open proposal to the digital media community and explores the possibilities of a decentralized content identifier system. We\u2019d like to establish an open standard for persistent, unique, vendor independent and content derived cross-media identifiers that can be stored and managed on global, public and decentralized blockchains. We envision a self-governing ecosystem with a low barrier of entry where commercial and non-commercial initiatives can both innovate and thrive next to each other.","title":"Introduction"},{"location":"concept/#media-identifiers-for-blockchains","text":"Media cataloging systems tend to get out of hand and become complex and often unmanageable. Our design proposal is focused on keeping the ISCC system as simple and more importantly as automatable as possible, while maximizing practical value for the most important use cases \u2014 meaning you should get out more than you have to put in. With this in mind we come to the following basic design decisions:","title":"Media Identifiers for Blockchains"},{"location":"concept/#a-meaningful-identifier","text":"In traditional database systems it is recommended practice to work with surrogate keys as identifiers. A surrogate key is a dumb number and has no business meaning and is completely decoupled from the data it identifies. Uniqueness of such identifiers is guaranteed either via centralized incremental assignment by the database system or via random UUIDs which have a very low probability of collisions. While random UUIDs could be generated in a decentralized way, both approaches require some external authority that establishes or certifies the linkage between the identifier and the associated metadata and content. This is why we decided to go with a \u201cmeaningful\u201d content and metadata derived identifier (CMDI) . Anyone will be able to verify that a specific identifier indeed belongs to a given digital content. Even better, anyone can \u201cfind\u201d the identifier for a given content without the need to consult external data sources. This approach also captures essential information about the media in the identifier itself, which is very useful in scenarios of machine learning and data analytics.","title":"A \u201cMeaningful\u201d Identifier"},{"location":"concept/#a-decentralized-identifier","text":"The ISCC is designed to be registry agnostic. This means that content identification codes can be self-issued in a decentralized and parallel fashion without the need for governance by a centralized registration agency. Without registration an ISCC is owned by the content and not by a person or organization. An unregistered ISCC is useful in cases where multiple independent parties exchange information about content. The CMDI approach is helpful with common issues like data integrity, validation, de-duplication and disambiguation. Systems that process digital content can integrate ISCC support and benefit immediately. The integrator does not depend on all third-parties having to assign, track and deliver ISCC codes, because those can be generated from the content itself. ISCC registration becomes necessary when an ISCC code needs to be globally unique, publicly discoverable, resolvable, owned or authenticated . While these features inevitably require some kind of registry, not all of them require a centralized institutional registry. In a centralized system the central authority is in control of the issuance of identifiers and safeguards various requirements like identifier uniqueness or ownership. In a decentralized system where everybody can register an identifier we need a different approach. The ISCC will specify the necessary protocols to implement the aforementioned features in a decentralized, federated environment and across multiple public blockchains. Given a registered ISCC code, an application can unambiguously determine on what blockchain (if any), by which account, and at what time an ISCC has been registered. Registered ISCC codes have to indicate an authoritative public blockchain network. This indicator is part of the ISCC Code itself, such that codes registered on different networks cannot collide. This guarantees uniqueness of ISCC codes across multiple blockchains. Ownership of ISCC codes (not the identified content) is granted to the signatory of the first transaction for a given ISCC code on the corresponding blockchain. Global uniqueness of ISCC codes is accomplished by the blockchain indicator in combination with a client side counter. Registration clients first check for a prior registration of a given ISCC code on a given blockchain. If the ISCC code is already registered by another account the client may simply increments a suffix of the code before registration. Applications are instructed to ignore duplicate registrations of identical codes that occur on a blockchain after an initial registration. This approach retains global clustering and de-duplication features while at the same time offering owned , authenticated and globally unique ISCC codes. The model also allows for verifiable transfers of ISCC ownership. Given an appropriate protocol it is even possible to switch the authoritative blockchain for an ISCC after initial registration without changing the ISCC code itself.","title":"A Decentralized Identifier"},{"location":"concept/#registration-services","text":"Registration services offer a plethora of valuable and indispensable benefits. Every industry has its special requirements. Ultimately the stakeholders from those industries will have to set the rules for data curation, metadata management and administrative control. A Blockchain is a low level backend infrastructure. And while blockchains might make access to identifiers and metadata more accessible, there is still cost involved with storing data, running the infrastructure and providing middleware and frontends. Blockchains work as incentive based economic systems. Registrars can offer commercially viable value added services on top of the lower level blockchain networks. For example: Identity verification of registrants Certification/attestation of registry entries Data curation and indexing services Blockchain key-management services Custodial blockchain account management Middleware and front-end applications Infrastructure operations Participation in blockchain network governance","title":"Registration Services"},{"location":"concept/#storage-considerations","text":"On a typical public blockchain all data is fully replicated among participants. This allows for independent and autonomous validation of transactions. All blockchain data is highly available, immutable, tamper-proof, timestamped and in most cases openly accessible. However, under high load the limited transaction capacity (storage space per unit of time) creates a transaction fee market for on-chain data. This leads to growing transaction costs and makes storage a scarce and increasingly precious resource on public decentralized blockchains. For example storing a 46 character identifier on the Ethereum blockchain in July 2019 cost ~ $0.50. So it is mandatory for our identifier and its eventual metadata schema to be very space efficient to maximize benefit at minimal cost. The basic metadata that will be required to generate and register identifiers must be: minimal in scope clearly specified robust against human error enforced on technical level adequate for public use (no legal or privacy issues)","title":"Storage Considerations"},{"location":"concept/#layers-of-digital-media-identification","text":"While we examined existing identifiers we discovered that there is often much confusion about the extent or coverage of what exactly is being identified by a given system. With our idea for a generic cross-media identifier we want to put special weight on being precise with our definitions and found it helpful to distinguish between \u201cdifferent layers of digital media identification\". We found that these layers exist naturally on a scale from abstract to concrete. Our analysis also showed that existing standard identifiers operate on one or at most two of such layers. The ISCC is designed as a composite identifier that takes the different layers of media identification into consideration:","title":"Layers of Digital Media Identification"},{"location":"concept/#layer-1-abstract-creation","text":"In the first and most abstract layer we are concerned with distinguishing between different works or creations in the broadest possible sense . The scope of identification is completely independent of any manifestations of the work, be it physical or digital in nature. It is also agnostic to creators, rights holders or any specific interpretations, expressions or language versions of a work. It only relates to the intangible creation - the idea itself.","title":"Layer 1 \u2013 Abstract Creation"},{"location":"concept/#layer-2-semantic-field","text":"This layer relates to the meaning or essence of a work. It is an amorphous collection or combination of facts, concepts, categories, subjects, topics, themes, assumptions, observations, conclusions, beliefs and other intangible things that the content conveys. The scope of identification is a set of coordinates within a finite and multidimensional semantic space.","title":"Layer 2 \u2013 Semantic Field"},{"location":"concept/#layer-3-generic-manifestation","text":"In this layer we are concerned with the literal structure of a media type specific and normalized manifestation. Namely the basic text, image, audio or video content independent of its semantic meaning or media file encoding and with a tolerance to variation. This \"tolerance to variation\" bundles a set of different versions with corrections, revisions, edits, updates, personalization, different format encodings or data compression of the same content under one grouping identifier. A generic manifestation is independent of a final digital media product and is specific to an expression, version or interpretation of a work. Unfortunately it is not obvious where generic manifestation of a work ends and another one starts. It depends on human interpretation and context. How much editing do we allow before we call it a \u201cdifferent\u201d manifestation and give it a different identifier. A practical but only partial solution to this problem is to create an algorithmically defined and testable spectrum of tolerance to variation per media type. This can provide a stable and repeatable process to distinguish between generic content manifestations. But it is important to understand that such a process is not expected to yield results that are always intuitive to human expectations as to where exactly boundaries should be.","title":"Layer 3 \u2013 Generic Manifestation"},{"location":"concept/#layer-4-media-specific-manifestation","text":"This layer relates to a manifestation with a specific encoding . It identifies a data-file encoded and offered in a specific media format including a tolerance to variation to account for minor edits and updates within a format without creating a new identifier. For example, one could distinguish between the PDF, DOCX or WEBSITE versions of the same content as generated from a single source publishing system. This layer does only distinguish between products or \"artifacts\" with a given packaging or encoding.","title":"Layer 4 \u2013 Media Specific Manifestation"},{"location":"concept/#layer-5-exact-representation","text":"In this layer we identify a data-file by its exact binary representation without any interpretation of meaning and without any ambiguity. Even a minimal change in data that might not change the interpretation of content would create a different identifier. Like the first four layers, this layer does not express any information related to content location or ownership .","title":"Layer 5 \u2013 Exact Representation"},{"location":"concept/#layer-6-individual-copy","text":"In the physical world we would call a specific book (one that you can take out of your shelve) an individual copy . This implies a notion of locality and ownership . In the digital world the semantics of an individual copy are very different. An individual copy might be distinguished by a license you own or by a personalized watermark applied by the retailer at time of sale or some digital annotations you have added to your digital media file. While there can only ever be one exact individual copy of a physical object , there always can be endless replicas of an \"individual copy\" of a digital object . It is very important to keep this difference in mind. Ignoring this fact has caused countless misunderstandings and is the source of confusion throughout the media industry \u2013 especially in the realm of copyright and license discussions. We could try to define an individual digital copy by its location and exact content on a specific physical storage medium (like a DVD, SSD ...). But this does not account for the fact that it is nearly impossible to stop someone from creating an exact replica of that data or at least a snapshot or recording of the presentation of that data on another storage location. And most importantly such a replica does not affect the original data and even less can make it magically disappear. In contrast, if you give your individual copy of your book to someone else, you won't \"have it\" anymore. It is clear, that with digital media this cannot reliably be the case . The only way would be to build a tamper-proof physical device (secure element) that does not reveal the data itself, which would defeat the purpose by making the content itself unavailable. But there are ways to partially simulate such inherently physical properties in the digital world. Most notably with the emergence of blockchain technology it is now possible to have a cryptographically secured and publicly notarized tamper-proof certificate of ownership. This can serve as a record of agreement about ownership of an \u201cindividual copy\u201d. But is does not by itself enforce location or accessibility of the content, nor does it prove the authorization of the certifying party itself or the legal validity of the agreement.","title":"Layer 6 \u2013 Individual Copy"},{"location":"concept/#design-principles","text":"As a generic content identifier the ISCC Standard is a an initiative with a broad scope. These are the principles that should guide its design and adoption: Target existing, unsolved, real-world problems Provide a technological and automatable solution Be generic and useful to a broad audience Keep the standard pragmatic and simple to implement Keep it extendable and forward compatible Provide marketable user-facing sample applications Provide machine readable test data for implementers Provide developer tools in different programming languages Promote implementations in different sectors The specification should be open and public Engage with other standards and interested parties","title":"Design Principles"},{"location":"concept/#algorithmic-tools","text":"While many details about the ISCC are still up for discussion we are quite confident about some of the general algorithmic families that will make it into the final specification for the identifier. These will play an important role in how we generate the different components of the identifier: Similarity preserving hash functions (Simhash, Minhash ...) Perceptual hashing (pHash, Blockhash, Chromaprint \u2026) Content defined chunking (Rabin-Karp, FastCDC ...) Merkle trees","title":"Algorithmic Tools"},{"location":"concept/#iscc-proof-of-concept","text":"Before we settle on the details of the proposed ISCC identifier, we built a simple and reduced proof-of-concept implementation of our ideas. It enables us and other developers to test with real world data and systems and find out early what works and what doesn't. Update An interactive demo of the concept is available at https://isccdemo.content-blockchain.org/ The minimal viable, first iteration ISCC will be a byte structure built from the following components:","title":"ISCC Proof-of-Concept"},{"location":"concept/#meta-code","text":"The Meta-Code will be generated as a similarity preserving hash from minimal generic metadata like title and creators . It operates on Layer 1 and identifies an intangible creation. It is the first and most generic grouping element of the identifier. We will be experimenting with different n-gram sizes and bit-length to find the practical limits of precision and recall for generic metadata. We will also specify a process to disambiguate unintended collisions by adding optional metadata.","title":"Meta-Code"},{"location":"concept/#partial-content-flag","text":"The Partial Content Flag is a 1-bit flag that indicates whether the remaining elements relate to the complete work or only to a subset of it.","title":"Partial Content Flag"},{"location":"concept/#media-type-flag","text":"The Media Type Flag is a 3 bit flag that allows us to distinguish between up to 8 generic media types (GMTs) to which our Content-Code component applies. We define a generic media type as basic content types such as plain text or raw pixel data that is specified exactly and extracted from more complex file formats or encodings. We start with generic text and image types and add audio, video and mixed types later.","title":"Media Type Flag"},{"location":"concept/#content-code","text":"The Content-Code operates on Layer 3 and will be a GMT-specific similarity preserving hash generated from extracted content. It identifies the normalized content of a specific GMT, independent of file format or encoding. It relates to the structural essence of the content and groups similar GMT-specific manifestations of the abstract creation or parts of it (as indicated by the Partial Content Flag). For practical reasons we intentionally skip a Layer 2 component at this time. It would add unnecessary complexity for a basic proof-of-concept implementation.","title":"Content-Code"},{"location":"concept/#data-code","text":"The Data-Code operates on Layer 4 and will be a similarity preserving hash generated from shift-resistant content-defined chunks from the raw data of the encoded media blob. It groups complete encoded files with similar content and encoding. This component does not distinguish between GMTs as the files may include multiple different generic media types.","title":"Data-Code"},{"location":"concept/#instance-code","text":"The Instance-Code operates on Layer 5 and will be the top hash of a Merkle tree generated from (potentially content-defined) chunks of raw data of an encoded media blob. It identifies a concrete manifestation and proves the integrity of the full content. We use the Merkle tree structure because it also allows as to verify integrity of partial chunks without having to have the full data available. This will be very useful in any scenarios of distributed data storage. We intentionally skip Layer 6 at this stage as content ownership and location will be handled on the blockchain layer of the stack and not by the ISCC identifier itself.","title":"Instance-Code"},{"location":"features/","text":"ISCC - Features # The ISCC comes with a number of built-in features: Granular Content Management # The ISCC can be generated for any work as well as for parts, chunks or individual elements of the content. These elements could be an image, a table, a chapter or a quote within a given document. The relation between parent and child-elements can be preserved in the ISCC identifier. Thus, it is possible to connect the various ID's, obtain their relations and identify the work from which any chunk is taken from. This feature can also help to identify plagiarism, in case chunks from one work have been used in a different work - only with access to the ISCC identifiers. Content Identification # The ISCC is a content code, that is created from the content file itself. Processing the content with the algorithms defined by ISCC specification creates a unique composite code, consisting of four major elements.The ISCC identifies content across multiple, hierarchical layers: From the embedded metadata, the normalized content, the encoded file format up to the individual file. It can be used to automatically distinguish different versions of the same content, to ensure data integrity, to de-duplicate, or to disambiguate content in a given content repository. Decentralized Issuance # The ISCC is managed in a decentralized fashion. This means that anyone with access to the content will be able to create and verify an ISCC based on the content files themselves. The ISCC can be created offline on any local device or app, that supports the suggested standard. The ISCC also ensures that if content files are sent, distributed or otherwise shared among different parties or repositories any participant can be sure to refer to the exact same content file. This will radically simplify digital distribution. Designed for Blockchain # The ISCC is designed to be used in a blockchain environment, but also creates value if being used locally, off-chain or even offline. The ISCC is short enough to be written on any blockchain while preserving its unique features. Or it can be used off-chain within a local content repository for internal processing or non-blockchain digital transactions.. Content Versioning # During content creation, review processes or distribution, same or similar files are being exchanged among various parties (editors, distributors, retailers, etc.). With the ISCC registered on the blockchain it is possible to timestamp all content versions and variants in order to create an auditable history of related documents over time. This helps to identify content variations on a time scale in order to make sure that users are referring to the correct same file or related versions of the same content. Related Product Identification # The Content-Code is one component of the ISCC. It is a similarity-preserving hash generated from extracted content. It identifies the normalized content of a specific file, independent of file format or encoding. As the Content-Code will remain the same for the same content in various formats, the ISCC automatically connects related formats, like PDF-, MS-word or EPUB-files or JPEG- and PNG-files, etc. Content Variant Detection # The similarity preserving hash of the Content-Code of the ISCC is able to cluster similar variants of content. It identifies the same or similar content and also shows on a scale from 1-64 (or 1-100%) how similar two content variants are. At the same time an application can distinguish between similar but not identical content through the Instance-Code component of the ISCC. This can help to identify e.g. watermarked files. Proof of Data Possession # With the ISCC and a standardized signing algorithm it will be possible to verify whether a user that created the ISCC entry on the blockchain actually had access to the respective content file.","title":"Features"},{"location":"features/#iscc-features","text":"The ISCC comes with a number of built-in features:","title":"ISCC - Features"},{"location":"features/#granular-content-management","text":"The ISCC can be generated for any work as well as for parts, chunks or individual elements of the content. These elements could be an image, a table, a chapter or a quote within a given document. The relation between parent and child-elements can be preserved in the ISCC identifier. Thus, it is possible to connect the various ID's, obtain their relations and identify the work from which any chunk is taken from. This feature can also help to identify plagiarism, in case chunks from one work have been used in a different work - only with access to the ISCC identifiers.","title":"Granular Content Management"},{"location":"features/#content-identification","text":"The ISCC is a content code, that is created from the content file itself. Processing the content with the algorithms defined by ISCC specification creates a unique composite code, consisting of four major elements.The ISCC identifies content across multiple, hierarchical layers: From the embedded metadata, the normalized content, the encoded file format up to the individual file. It can be used to automatically distinguish different versions of the same content, to ensure data integrity, to de-duplicate, or to disambiguate content in a given content repository.","title":"Content Identification"},{"location":"features/#decentralized-issuance","text":"The ISCC is managed in a decentralized fashion. This means that anyone with access to the content will be able to create and verify an ISCC based on the content files themselves. The ISCC can be created offline on any local device or app, that supports the suggested standard. The ISCC also ensures that if content files are sent, distributed or otherwise shared among different parties or repositories any participant can be sure to refer to the exact same content file. This will radically simplify digital distribution.","title":"Decentralized Issuance"},{"location":"features/#designed-for-blockchain","text":"The ISCC is designed to be used in a blockchain environment, but also creates value if being used locally, off-chain or even offline. The ISCC is short enough to be written on any blockchain while preserving its unique features. Or it can be used off-chain within a local content repository for internal processing or non-blockchain digital transactions..","title":"Designed for Blockchain"},{"location":"features/#content-versioning","text":"During content creation, review processes or distribution, same or similar files are being exchanged among various parties (editors, distributors, retailers, etc.). With the ISCC registered on the blockchain it is possible to timestamp all content versions and variants in order to create an auditable history of related documents over time. This helps to identify content variations on a time scale in order to make sure that users are referring to the correct same file or related versions of the same content.","title":"Content Versioning"},{"location":"features/#related-product-identification","text":"The Content-Code is one component of the ISCC. It is a similarity-preserving hash generated from extracted content. It identifies the normalized content of a specific file, independent of file format or encoding. As the Content-Code will remain the same for the same content in various formats, the ISCC automatically connects related formats, like PDF-, MS-word or EPUB-files or JPEG- and PNG-files, etc.","title":"Related Product Identification"},{"location":"features/#content-variant-detection","text":"The similarity preserving hash of the Content-Code of the ISCC is able to cluster similar variants of content. It identifies the same or similar content and also shows on a scale from 1-64 (or 1-100%) how similar two content variants are. At the same time an application can distinguish between similar but not identical content through the Instance-Code component of the ISCC. This can help to identify e.g. watermarked files.","title":"Content Variant Detection"},{"location":"features/#proof-of-data-possession","text":"With the ISCC and a standardized signing algorithm it will be possible to verify whether a user that created the ISCC entry on the blockchain actually had access to the respective content file.","title":"Proof of Data Possession"},{"location":"license/","text":"License # TITLE : ISCC - Content Codes ISCC : CCDFPFc87MhdT-CTg5dAueXoTwU-CDFo1xv7eF4sD CC BY-NC-SA 4.0 License Copyright \u00a9 2016 - 2020 The Authors, Content Blockchain Project This work is licensed under a Creative Commons (CC BY-NC-SA 4.0) .","title":"License"},{"location":"license/#license","text":"TITLE : ISCC - Content Codes ISCC : CCDFPFc87MhdT-CTg5dAueXoTwU-CDFo1xv7eF4sD CC BY-NC-SA 4.0 License Copyright \u00a9 2016 - 2020 The Authors, Content Blockchain Project This work is licensed under a Creative Commons (CC BY-NC-SA 4.0) .","title":"License"},{"location":"resources/","text":"ISCC - Resources # If you find something that is missing from this collection of resources for the ISCC, please add it . ISCC - Official Software & Tools # ISCC - CLI # An open-source command-line tool that can be used on Windows , Linux , and Mac systems by developers and computer savvy persons to create ISCC codes from media files and URLs. The tool is based on the reference implementation but also includes new and experimental features (e.g., Audio-Codes, Video-Codes) that are not yet part of the public specification . ISCC - Web Service # A REST OpenAPI backend service application for creating ISCC codes for digital media files and URLs. The Webservice is built with FastAPI and makes use of the ISCC reference implementation and the ISCC Command Line Tool and includes interactive API documentation. ISCC - Specification & Reference Implementation # The official ISCC reference implementation. The reference code is published on the Python Package Index and can be installed as a library by developers. The ISCC specification is written in markdown and hosted in the same source code repository and published at http://iscc.codes/specification . For contributions and public discussions, please use the corresponding issue tracker . ISCC - Third-Party Implementations # ISCC-RS # Rust implementation of the ISCC specification . ISCC-RS-CLI # Command-line tool based on the iscc-rs library. ISCC-GOLANG # Golang implementation of the ISCC protocol. ISCC-DOTNET # C# .Net Core implementation of the ISCC protocol. ISCC - Technical Demos & Integrations # Web Demo # A demo web application that can generate and lookup ISCC codes from files or URLs and visualizes differences between ISCC Codes. The source code is also available. Data Streams # The Content Blockchain Testnet is running a public data-stream of ISCC codes for testing and demonstration purposes. The web demo uses the ISCC data-stream for lookups. Clink.ID # CLink.ID is an interoperable registry, architected to recognize identifiers and meta-data regardless of whether they are Handle- or content-based and/or block-chain inspired. CLink.ID is operated by CLink Media , Inc. and has integrated ISCC in its registry . Smart License Demo # Prototype demo of a smart licensing framework that uses ISCC codes for content identification. Source code is also available. Blockchain Wallet Demo # An early prototype demo of a blockchain wallet that uses ISCC codes for license tokenization. ISCC - Presentations & Articles # Blockchain for Science Conference (Berlin, 2019) # ISCC - Similarity hashing for digital content identification in decentralized environments. Recording of the 30-minute talk. Organizations and Initiatives # ISCC Foundation # The ISCC Foundation is an independent international nonprofit organization that promotes information technologies for the common good. In particular, the foundation supports the ISCC and promotes the development and adoption of open standards and open source technologies as well as tools and services that enable individuals and organizations to better create, manage, discover, access, share, and monetize digital content, knowledge, and ideas . ISO - International Organization for Standardization # ISO/TC 46/SC 9 (Identification and description) has accepted the International Standard Content Code as a preliminary work item and created a new working group (WG 18 - Digital-Content-Based Identification).","title":"Resources"},{"location":"resources/#iscc-resources","text":"If you find something that is missing from this collection of resources for the ISCC, please add it .","title":"ISCC - Resources"},{"location":"resources/#iscc-official-software-tools","text":"","title":"ISCC - Official Software &amp; Tools"},{"location":"resources/#iscc-cli","text":"An open-source command-line tool that can be used on Windows , Linux , and Mac systems by developers and computer savvy persons to create ISCC codes from media files and URLs. The tool is based on the reference implementation but also includes new and experimental features (e.g., Audio-Codes, Video-Codes) that are not yet part of the public specification .","title":"ISCC - CLI"},{"location":"resources/#iscc-web-service","text":"A REST OpenAPI backend service application for creating ISCC codes for digital media files and URLs. The Webservice is built with FastAPI and makes use of the ISCC reference implementation and the ISCC Command Line Tool and includes interactive API documentation.","title":"ISCC - Web Service"},{"location":"resources/#iscc-specification-reference-implementation","text":"The official ISCC reference implementation. The reference code is published on the Python Package Index and can be installed as a library by developers. The ISCC specification is written in markdown and hosted in the same source code repository and published at http://iscc.codes/specification . For contributions and public discussions, please use the corresponding issue tracker .","title":"ISCC - Specification &amp; Reference Implementation"},{"location":"resources/#iscc-third-party-implementations","text":"","title":"ISCC - Third-Party Implementations"},{"location":"resources/#iscc-rs","text":"Rust implementation of the ISCC specification .","title":"ISCC-RS"},{"location":"resources/#iscc-rs-cli","text":"Command-line tool based on the iscc-rs library.","title":"ISCC-RS-CLI"},{"location":"resources/#iscc-golang","text":"Golang implementation of the ISCC protocol.","title":"ISCC-GOLANG"},{"location":"resources/#iscc-dotnet","text":"C# .Net Core implementation of the ISCC protocol.","title":"ISCC-DOTNET"},{"location":"resources/#iscc-technical-demos-integrations","text":"","title":"ISCC - Technical Demos &amp; Integrations"},{"location":"resources/#web-demo","text":"A demo web application that can generate and lookup ISCC codes from files or URLs and visualizes differences between ISCC Codes. The source code is also available.","title":"Web Demo"},{"location":"resources/#data-streams","text":"The Content Blockchain Testnet is running a public data-stream of ISCC codes for testing and demonstration purposes. The web demo uses the ISCC data-stream for lookups.","title":"Data Streams"},{"location":"resources/#clinkid","text":"CLink.ID is an interoperable registry, architected to recognize identifiers and meta-data regardless of whether they are Handle- or content-based and/or block-chain inspired. CLink.ID is operated by CLink Media , Inc. and has integrated ISCC in its registry .","title":"Clink.ID"},{"location":"resources/#smart-license-demo","text":"Prototype demo of a smart licensing framework that uses ISCC codes for content identification. Source code is also available.","title":"Smart License Demo"},{"location":"resources/#blockchain-wallet-demo","text":"An early prototype demo of a blockchain wallet that uses ISCC codes for license tokenization.","title":"Blockchain Wallet Demo"},{"location":"resources/#iscc-presentations-articles","text":"","title":"ISCC - Presentations &amp; Articles"},{"location":"resources/#blockchain-for-science-conference-berlin-2019","text":"ISCC - Similarity hashing for digital content identification in decentralized environments. Recording of the 30-minute talk.","title":"Blockchain for Science Conference (Berlin, 2019)"},{"location":"resources/#organizations-and-initiatives","text":"","title":"Organizations and Initiatives"},{"location":"resources/#iscc-foundation","text":"The ISCC Foundation is an independent international nonprofit organization that promotes information technologies for the common good. In particular, the foundation supports the ISCC and promotes the development and adoption of open standards and open source technologies as well as tools and services that enable individuals and organizations to better create, manage, discover, access, share, and monetize digital content, knowledge, and ideas .","title":"ISCC Foundation"},{"location":"resources/#iso-international-organization-for-standardization","text":"ISO/TC 46/SC 9 (Identification and description) has accepted the International Standard Content Code as a preliminary work item and created a new working group (WG 18 - Digital-Content-Based Identification).","title":"ISO - International Organization for Standardization"},{"location":"specification/","text":"ISCC - Specification v1.x # Last revised: 2022-10-10 16:40:22 Warning This document is out of date early draft and retained for historic reasons only. Please follow current development at https://ieps.iscc.codes Abstract # The International Standard Content Code ( ISCC ) , is an open and decentralized digital media identifier. An ISCC can be created from digital content and its basic metadata by anybody who follows the procedures of the ISCC specification or by using open source software that supports ISCC creation conforming to the ISCC specification . Note to Readers # For public discussion of issues for this specification, please use the Github issue tracker: https://github.com/iscc/iscc-specs/issues . If you want to chat with developers, join us on Telegram at https://t.me/iscc_dev . You can find the latest version of this specification at http://iscc.codes/specification/ . Public review, discussion and contributions are welcome. About this Document # Document Version While there is already a Version 1.0 spec, we are still expecting backward incompatible changes until Version 2.0 . Parts of this specification may become stable earlier. We will document this during minor releases. We encourage partners to follow development and test, implement, and give feedback based on the latest (this) version of the ISCC Specification. This document proposes an open and vendor neutral ISCC standard and describes the technical procedures to create and manage ISCC identifiers. The first version of this document resulted from a prototyping project by the Content Blockchain Project and received funding from the Google Digital News Initiative (DNI) . The content of this document results from a voluntary effort of the authors with an open and public consensus process. Conventions and Terminology # The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC 2119] . Definitions # Basic Metadata: Minimal set of ISCC -specific top-level metadata that applications SHOULD support. Bound Metadata: Metadata that is utilized during generation of the ISCC . A change of this bound metadata may therefore impact the derived ISCC .. Extended Metadata: Industry and application-specific metadata attached to an ISCC . Character: Throughout this specification a character is meant to be interpreted as one Unicode code point. This also means that due to the structure of Unicode a character is not necessarily a full glyph but might be a combining accent or similar. Digital Media Object: A blob of raw bytes with some media type specific encoding. Extended Metadata: Metadata that is not encoded within the ISCC Meta-Code but may be supplied together with the ISCC . Generic Media Type: A basic content type such as plain text in a normalized and generic ( UTF-8 ) encoding format. ISCC : International Standard Content Code ISCC Code : The printable text encoded representation of an ISCC ISCC Digest : The raw binary data of an ISCC Introduction # An ISCC permanently identifies content at multiple levels of granularity . It is algorithmically generated from basic metadata and the contents of a digital media object. It is designed for being registered and stored on a public and decentralized blockchain. An ISCC for a media object can be created and registered by the content author, a publisher, a service provider or anybody else. By itself the ISCC and its basic registration on a blockchain does not make any statement or claim about authorship or ownership of the identified content. ISCC Structure # A Fully Qualified ISCC Digest is a fixed size sequence of 36 bytes (288 bits) assembled from multiple sub-components. The Fully Qualified ISCC Code is a 52 character encoded printable string representation of a complete ISCC Digest . This is a high-level overview of the ISCC creation process: ISCC Components # The ISCC Digest is built from multiple self-describing 72-bit components: Components: Meta-Code Content-Code Data-Code Instance-Code Context: Intangible creation Content similarity Data similarity Data checksum Input: Metadata Extracted content Raw data Raw data Algorithms: Similarity Hash Type specific CDC , Minimum Hash Hash Tree Size: 72 bits 72 bits 72 bits 72 bits ISCC components MAY be used separately or in combination by applications for various purposes. Individual components MUST be presented as 13- character base58-iscc encoded strings to end users and MAY be prefixed with their component name. Single component ISCC -Code (13 characters) Meta-Code : CCDFPFc87MhdT Combinations of components MUST include the Meta-Code component and MUST be ordered as Meta-Code , Content-Code , Data-Code , and Instance-Code . Individual components MAY be skipped and SHOULD be separated with hyphens. A combination of components SHOULD be prefixed with \" ISCC \". Combination of ISCC -Code components ISCC : CCPktvj3dVoVa-CTPCWTpGPMaLZ-CDL6QsUZdZzog A Fully Qualified ISCC Code is an ordered sequence of Meta-Code, Content-Code, Data-Code, and Instance-Code codes. It SHOULD be prefixed with ISCC and MAY be separated by hyphens. Fully Qualified ISCC -Code (52 characters) ISCC : CCDFPFc87MhdTCTWAGYJ9HZGj1CDhydSjutScgECR4GZ8SW5a7uc Fully Qualified ISCC -Code with hyphens (55 characters) ISCC : CCDFPFc87MhdT-CTWAGYJ9HZGj1-CDhydSjutScgE-CR4GZ8SW5a7uc Component Types # Each component has the same basic structure of a 1-byte header and a 8-byte body section. The 1-byte header of each component is subdivided into 2 nibbles (4 bits). The first nibble specifies the component type while the second nibble is component specific. The header only needs to be carried in the encoded representation. As similarity searches across different components are of little use, the type-information contained in the header of each component can be safely ignored after an ISCC has been decomposed and internally typed by an application. List of Component Headers # Component Nibble-1 Nibble-2 Byte Code Meta-Code 0000 0000 - Reserved 0x00 CC Content-Code-Text 0001 0000 - Content Type Text 0x10 CT Content-Code-Text PCF 0001 0001 - Content Type Text + PCF 0x11 Ct Content-Code-Image 0001 0010 - Content Type Image 0x12 CY Content-Code-Image PCF 0001 0011 - Content Type Image + PCF 0x13 Ci Content-Code-Audio 0001 0100 - Content Type Audio 0x14 CA Content-Code-Audio PCF 0001 0101 - Content Type Audio + PCF 0x15 Ca Content-Code-Video 0001 0110 - Content Type Video 0x16 CV Content-Code-Video PCF 0001 0111 - Content Type Video + PCF 0x17 Cv Content-Code-Mixed 0001 1000 - Content Type Mixed 0x18 CM Content-Code Mixed PCF 0001 1001 - Content Type Mixed + PCF 0x19 Cm Data-Code 0010 0000 - Reserved 0x20 CD Instance-Code 0011 0000 - Reserved 0x30 CR The body section of each component is specific to the component and always 8-bytes and can thus be fit into a 64-bit integer for efficient data processing. The following sections give an overview of how the different components work and how they are generated. Meta-Code Component # The Meta-Code component starts with a 1-byte header 00000000 . The first nibble 0000 indicates that this is a Meta-Code component type. The second nibble is reserved for future extended features of the Meta-Code. The Meta-Code body is built from a 64-bit similarity_hash over 4- character n-grams of the basic metadata of the content to be identified. The basic metadata supplied to the Meta-Code generating function is assumed to be UTF-8 encoded. Errors that occur during the decoding of such a byte string input to a native Unicode MUST terminate the process and must not be silenced. An ISCC generating application MUST provide a meta_id function that accepts minimal and generic metadata and returns a Base58- ISCC encoded Meta-Code component and trimmed metadata. Inputs to Meta-Code function # Name Type Required Description title text Yes The title of an intangible creation. extra text No An optional short statement that distinguishes this intangible creation from another one for forced Meta-Code uniqueness. (default: empty string) Note The basic metadata inputs are intentionally simple and generic. We abstain from more specific metadata for Meta-Code generation in favor of compatibility across industries. To support global clustering, it is RECOMMENDED to only supply the title field for Meta-Code generation. Imagine a creator input-field for metadata. Who would you list as the creators of a movie? The directors, writers, the main actors? Would you list some of them or if not how do you decide whom you will list. Global disambiguation of similar title data can be accomplished with the extra-field. Industry- and application-specific metadata requirements can be met by extended metadata . Generate Meta-Code # An ISCC generating application must follow these steps in the given order to produce a stable Meta-Code: Apply text_normalize separately to the title and extra inputs while keeping white space. Apply text_trim to the results of the previous step. The results of this step MUST be supplied as basic metadata for ISCC registration. Concatenate trimmed title and extra from using a space ( \\u0020 ) as a separator. Remove leading/trailing whitespace. Create a list of 4 character n-grams by sliding character -wise through the result of the previous step. Encode each n-gram from the previous step to an UTF-8 bytestring and calculate its xxHash64 digest. Apply similarity_hash to the list of digests from the previous step. Prepend the 1-byte component header ( 0x00 ) to the results of the previous step. Encode the resulting 9 byte sequence with encode Return encoded Meta-Code, trimmed title and trimmed extra data. See also: Meta-Code reference code Text trimming When trimming text be sure to trim the byte-length of the UTF-8 encoded version and not the number of characters. The trim point MUST be such that it does not cut into multi-byte characters. Characters might have different UTF-8 byte-length. For example \u00fc is 2-bytes, \u9a69 is 3-bytes and \ud841\udf0e is 4-bytes. So the trimmed version of a string with 128 \u9a69 -characters will result in a 42- character string with a 126-byte UTF-8 encoded length. This is necessary because the results of this operation will be stored as basic metadata with strict byte size limits on the blockchain. Automated Data-Ingestion Applications that perform automated data-ingestion SHOULD apply a customized preliminary normalization to title data tailored to the dataset. Depending on catalog data removing pairs of brackets [], (), {}, and text in between them or cutting all text after the first occurence of a semicolon (;) or colon (:) can vastly improve deduplication. Dealing with Meta-Code collisions # Ideally we want multiple ISCCs that identify different manifestations of the same intangible creation to be automatically grouped by an identical leading Meta-Code component. We call such a natural grouping an intended component collision . Metadata, captured and edited by humans, is notoriously unreliable. By using normalization and a similarity hash on the metadata, we account for some of this variation while keeping the Meta-Code component somewhat stable. Auto-generated Meta-Codes components are expected to miss some intended collisions. An application SHOULD check for such missed intended component collisions before registering a new Meta-Code with the canonical registry of ISCCs by conducting a similarity search and asking for user feedback. But what about unintended component collisions ? Such collisions might happen because two different intangible creations have very similar or even identical metadata. But they might also happen by chance. With 2^56 possible Meta-Code components the probability of random collisions rises in an S-curved shape with the number of deployed ISCCs (see: Hash Collision Probabilities ). We should keep in mind that the Meta-Code component is only one part of a fully qualified ISCC Code . Unintended collisions of the Meta-Code component are generally deemed as acceptable and expected . If for any reason an application wants to avoid unintended collisions with pre-existing Meta-Code components, it may use the extra -field. An application MUST first generate a Meta-Code without asking the user for input to the extra -field and then first check for collisions with the canonical registry of ISCCs. After it finds a collision with a pre-existing Meta-Code it may display the metadata of the colliding entry and interact with the user to determine if it is an unintended collision. Only if the user indicates an unintended collision, may the application ask for a disambiguation that is then added as an amendment to the metadata via the extra -field to create a different Meta-Code component. The application may repeat the pre-existence check until it finds no collision or a user intended collision. The application MUST NOT supply auto-generated input to the extra -field. It is our opinion that the concept of intended collisions of Meta-Code components is a useful concept and a net positive. But one must know that this characteristic also has its pitfalls. It is not an attempt to provide an unambiguous - agreed upon - definition of \"identical intangible creations\" . Content-Code Component # The Content-Code component has multiple subtypes. The subtypes correspond with the Generic Media Types ( GMT ) . A fully qualified ISCC can only have one Content-Code component of one specific GMT , but there may be multiple ISCCs with different Content-Code types per digital media object. A Content-Code is generated in two broad steps. In the first step, we extract and convert content from a rich media type to a normalized GMT . In the second step, we use a GMT -specific process to generate the Content-Code component of an ISCC . Generic Media Types # The Content-Code type is signaled by the first 3 bits of the second nibble of the first byte of the Content-Code: Content-Code Type Nibble 2 Bits 0-3 Description text 000 Generated from extracted and normalized plain-text image 001 Generated from normalized grayscale pixel data audio 010 To be defined in a later version of the specification video 011 To be defined in a later version of the specification mixed 100 Generated from multiple Content-Codes 101, 110, 111 Reserved for future versions of specification Content-Code-Text # The Content-Code-Text is built from the extracted plain-text content of an encoded media object. To build a stable Content-Code-Text the plain-text content must first be extracted from the digital media object. It should be extracted in a way that is reproducible. There are many text document formats out in the wild and extracting plain-text from all of them is anything but a trivial task. While text-extraction is out of scope for this specification it is RECOMMENDED, that plain-text content SHOULD be extracted with the open-source Apache Tika v1.23 toolkit, if a generic reproducibility of the Content-Code-Text component is desired. An ISCC generating application MUST provide a content_id(text, partial=False) function that accepts UTF-8 encoded plain text and a boolean, indicating the partial content flag as input and returns a Content-Code with GMT type text . The procedure to create a Content-Code-Text is: Apply text_normalize to the text input while removing white-space. Create character -wise n-grams of length 13 from the normalized text. Create a list of 32-bit unsigned integer features by applying xxHash32 to the results of the previous step. Apply minimum_hash to the list of features from the previous step with n=64. Collect the least significant bits from the 64 MinHash features from the previous step. Create a 64-bit digest from the collected bits. Prepend the 1-byte component header ( 0x10 full content or 0x11 partial content). Encode and return the resulting 9-byte sequence with encode . See also: Content-Code-Text reference code Content-Code-Image # For the Content-Code-Image we are opting for a DCT-based perceptual image-hash instead of a more sophisticated key-point detection based method. In view of the generic deployability of the ISCC we chose an algorithm that has moderate computation requirements and is easy to implement while still being robust against common image manipulations. An ISCC generating application MUST provide a content_id_image(image, partial=False) function that accepts a local file path to an image and returns a Content-Code with GMT type image . The procedure to create a Content-Code-Image is as follows: Apply image_normalize to receive a two-dimensional array of gray-scale pixel data. Apply image_hash to the results of the previous step. Prepend the 1-byte component header ( 0x12 full content or 0x13 partial content) to results of the previous step. Encode and return the resulting 9-byte sequence with encode See also: Content-Code-Image reference code Image Data Input The content_id_image function may optionally accept the raw byte data of an encoded image or an internal native image object as input for convenience. JPEG Decoding Decoding of JPEG images is non deterministic. Different image processing libraries may yield diverging pixel data and result in different Image-IDs. The reference implementation uses the built-in decoder of the Python Pillow imaging library. Future versions of the ISCC specification may define a custom deterministic JPEG decoding procedure. Content-Code-Mixed # The Content-Code-Mixed aggregates multiple Content-Codes of the same or different types. It may be used for digital media objects that embed multiples types of media or for collections of contents of the same type. First, we have to collect contents from the mixed media object or content collection and generate Content-Codes for each item. An ISCC conforming application must provide a content_id_mixed function that takes a list of Content-Code Codes as input and returns a Content-Code-Mixed. Follow these steps to create a Content-Code-Mixed: Signature: conent_id_mixed(cids: List[str], partial: bool=False) -> str Decode the list of Content-Codes. Extract the first 8-bytes from each digest ( Note : this includes the header part of the Content-Codes). Apply similarity_hash to the list of digests from step 2. Prepend the 1-byte component header( 0x18 full content or 0x19 partial content) Apply encode to the result of step 5 and return the result. See also: Content-Code-Mixed reference code Partial Content Flag ( PCF ) # The last bit of the header byte of the Content-Code is the \"Partial Content Flag\". It designates if the Content-Code applies to the full content, or just some part of it. The PCF MUST be set as a 0 -bit ( full GMT -specific content ) by default. Setting the PCF to 1 enables applications to create multiple linked ISCCs of partial extracts of a content collection. The exact semantics of partial content are outside of the scope of this specification. Applications that plan to support partial Content-Codes MUST define their semantics. PCF Linking Example Let's assume we have a single newspaper issue \"The Times - 03 Jan 2009\". You would generate one Meta-Code component with the title \"The Times\" and extra \"03 Jan 2009\". The resulting Meta-Code component will be the grouping prefix in this scenario. We use a Content-Code-Mixed with PCF 0 (not partial) for the ISCC of the newspaper issue. We generate Data-Code and Instance-Code from the print PDF of the newspaper issue. To create an ISCC for a single extracted image that should convey context with the newspaper issue, we reuse the Meta-Code of the newspaper issue and create a Content-Code-Image with PCF 1 (partial to the newspaper issue). For the Data-Code or Instance-Code of the image, we are free to choose if we reuse those of the newspaper issue or create separate ones. The former would express strong specialization of the image to the newspaper issue (not likely to be useful out of context). The latter would create a stronger link to an eventual standalone ISCC of the image. Note that the ISCC of the individual image keeps links in both ways: Image is linked to the newspaper issue by identical Meta-Code component Image is linked to the standalone version of the image by identical Content-Code-Image body This is just one example that illustrates the flexibility that the PCF -Flag provides in concert with a grouping Meta-Code. With great flexibility comes great danger of complexity. Applications SHOULD do careful planning before using the PCF -Flag with internally defined semantics. Data-Code Component # For the Data-Code that encodes data similarity we use a content defined chunking algorithm that provides some shift resistance and calculate the MinHash from those chunks. To accommodate for small files, the first 100 chunks have a ~140-byte size target while the remaining chunks target ~ 6kb in size. The Data-Code is built from the raw encoded data of the content to be identified. An ISCC generating application MUST provide a data_id function that accepts the raw encoded data as input. Generate Data-Code # Apply data_chunks to the raw encoded content data. For each chunk, calculate the xxHash32 integer hash. Apply minimum_hash to the resulting list of 32-bit unsigned integers with n=64. Collect the least significant bits from the 64 MinHash features. Create a 64-bit digest from the collected bits. Prepend the 1-byte component header (eg. 0x20). Apply encode to the result of step 6 and return the result. See also: Data-Code reference code Instance-Code Component # The Instance-Code is built from the raw data of the media object to be identified and serves as checksum for the media object. The raw data of the media object is split into 64-kB data-chunks. Then we build a hash-tree from those chunks and use the truncated tophash (Merkle root) as component-body of the Instance-Code. To guard against length-extension attacks and second preimage attacks, we use double sha256 for hashing. We also prefix the hash input data with a 0x00 -byte for the leaf nodes hashes and with a 0x01 -byte for the internal node hashes. While the Instance-Code itself is a non-cryptographic checksum, the full tophash may be supplied in the extended metadata of an ISCC secure integrity verification is required. An ISCC generating application MUST provide a instance_id function that accepts the raw data file as input and returns an encoded Instance-Code and a full hex-encoded 256-bit tophash . Generate Instance-Code # Split the raw bytes of the encoded media object into 64-kB chunks. For each chunk, calculate the sha256d of the concatenation of a 0x00 -byte and the chunk bytes. We call the resulting values leaf node hashes ( LNH ). Calculate the next level of the hash tree by applying sha256d to the concatenation of a 0x01 -byte and adjacent pairs of LNH values. If the length of the list of LNH values is uneven, concatenate the last LNH value with itself. We call the resulting values internal node hashes ( INH ). Recursively apply 0x01 -prefixed pair-wise hashing to the results of the last step until the process yields only one hash value. We call this value the tophash . Trim the resulting tophash to the first 8 bytes. Prepend the 1-byte component header (e.g. 0x30 ). Encode resulting 9-byte sequence with encode to an Instance-Code Code Hex-Encode the tophash Return the Instance-Code and the hex-encoded tophash See also: Instance-Code reference code Applications may carry, store, and process the leaf node hashes for advanced streaming data identification or partial data integrity verification. ISCC Metadata # As a generic content identifier, the ISCC makes minimal assumptions about metadata that must or should be supplied together with an ISCC . The RECOMMENDED data-interchange format for ISCC metadata is JSON . We distinguish between Basic Metadata and Extended Metadata : Basic Metadata # Basic metadata for an ISCC is metadata that is explicitly defined by this specification. The following table enumerates basic metadata fields for the top-level of the JSON metadata object: Name Type Required Bound Description version integer No No Version of ISCC Specification. Assumed to be 1 if omitted. title text Yes Yes The title of an intangible creation identified by the ISCC . The normalized and trimmed UTF-8 encoded text MUST not exceed 128 bytes. The result of processing title and extra data with the meta_id function MUST match the Meta-Code component of the ISCC . extra text No Yes An optional short statement that distinguishes this intangible creation from another one for Meta-Code uniqueness. tophash text (hex) No No The full hex-encoded tophash (Merkle root) returned by the instance_id function. meta array No No A list of one or more extended metadata entries. Must include at least one entry if specified. Attention Bound metadata impacts the ISCC Code (Meta-Code) and cannot be changed afterwards. Depending on adoption and real world use, future versions of this specification may define new basic metadata fields. Applications MAY add custom fields at the top level of the JSON object, but MUST prefix those fields with an underscore to avoid collisions with future extensions of this specification. Extended Metadata # Extended metadata for an ISCC is metadata that is not explicitly defined by this specification. All such metadata SHOULD be supplied as JSON objects within the top-level meta -array field. This allows for a flexible and extendable way to supply additional industry specific metadata about the identified content. Extended metadata entries MUST be wrapped in JSON object of the following structure: Name Description schema The schema -field may indicate a well-known metadata schema (such as Dublin Core, IPTC, ID3v2, ONIX) that is used. RECOMMENDED schema : \" schema.org \" mediatype The mediatype -field specifies an IANA Media Type . RECOMMENDED mediatype : \"application/ld+json\" url An URL that is expected to host the metadata with the indicated schema and mediatype . This field is only required if the data -field is omitted. data The data -field holds the metadata conforming to the indicated schema and mediatype. It is only required if the url field is omitted. ISCC Registration # The ISCC is a decentralized identifier. ISCCs can be generated for content by anybody who has access to the content. Because of the clustering properties of its components, the ISCC provides utility in data interchange and de-duplication scenarios even without a global registry. There is no central authority for the registration of ISCC codes or certification of content authorship. As an open system, the ISCC allows any person or organization to offer ISCC registration services as they see fit and without the need to ask anyone for permission. This also presumes that no person or organization may claim exclusive authority about ISCC registration. Blockchain Registry # To properly address the questions of identifier uniqueness, ownership and authentication within the ISCC Standard, the assignment of a set of canonical blockchain is a requirement. The distributed nature of blockchains are a perfect fit for long-term persistent identifier registration and resolver services. The assignment of a set of canonical blockchains is NOT YET part of this specification. Because this decision is of such vital importance, we suggest waiting for further feedback and additional community involvement before we address these questions either in an updated version of this specification or in a separate specification. Our recommendation to the community is to agree on a set of decentralized, open, and public blockchains that have specific support for registry-services. This would maximize the value for all participants in the ecosystem. Governance and protocol related questions are being worked on by many projects. See also: ISCC -Stream specification . ISCC Embedding # Embedding ISCC codes into content is only RECOMMENDED if it does not create a side effect. We call it a side effect if embedding an ISCC code changes the content to such an extent, that it yields a different ISCC code. Side effects will depend on the combination of ISCC components that are to be embedded. A Meta-Code can always be embedded without side effects because it does not depend on the content itself. Content-Code and Data-Code may not change if embedded in larger media objects. Instance-Codes cannot easily be embedded as they will inevitably have a side effect on the post-embedding Instance-Code without special processing. Applications MAY embed ISCC codes that have side effects if they specify a procedure by which the embedded ISCC codes can be stripped in such a way that the stripped content will yield the original embedded ISCC codes. ISCC Embedding We can embed the following combination of components from the markdown version of this document into the document itself because adding or removing them has no side effect: ISCC : CCDbMYw6NfC8a-CTtW9UFozcmBJ-CDYJsRdBNAERM ISCC URI Scheme # Provisional Section The ISCC URI Scheme and link-resolver details ultimately depend on identifier registration, ownership, uniqueness and governance related decisions which are not yet part of this specification. See also: Blockchain Registry . The purpose of the ISCC URI scheme based on RFC 3986 is to enable users to discover information like metadata or license offerings from an ISCC marked content by clicking a link on a webpage or by scanning a QR-Code. The scheme name is iscc . The path component MUST be a fully qualified ISCC Code without hyphens. An optional stream query key MAY indicate the blockchain stream information source. If the stream query key is omitted, applications SHOULD return information from the open ISCC Stream . The scheme name component (\"iscc:\") is case-insensitive. Applications MUST accept any combination of uppercase and lowercase letters in the scheme name. All other URI components are case-sensitive. Applications MAY register themselves as a handler for the \"iscc:\" URI scheme if no other handler is already registered. If another handler is already registered, an application MAY ask the user to change it on the first run of the application. URI Syntax # <foo> means placeholder, [bar] means optional. iscc:<fq-iscc-code>[?stream=<name>] URI Example # iscc:11TcMGvUSzqoM1CqVA3ykFawyh1R1sH4Bz8A1of1d2Ju4VjWt26S?stream=smart-license Procedures & Algorithms # Base58- ISCC # The ISCC uses a custom per-component data encoding similar to the zbase62 encoding by Zooko Wilcox-O'Hearn but with a 58- character symbol table. The encoding does not require padding and will always yield component codes of 13 characters length for 72-bit component digests. The predictable size of the encoding is a property that allows for easy composition and decomposition of components without having to rely on a delimiter (hyphen) in the ISCC code representation. Colliding body segments of the digest are preserved by encoding the header and body separately. The ASCII symbol table also minimizes transcription and OCR errors by omitting the easily confused characters 'O', '0', 'I', 'l' and is shuffled to generate human readable component headers. Symbol table SYMBOLS = \"C23456789rB1ZEFGTtYiAaVvMmHUPWXKDNbcdefghLjkSnopRqsJuQwxyz\" encode # Signature: encode(digest: bytes) -> str The encode function accepts a 9-byte ISCC Component Digest and returns the Base58- ISCC encoded alphanumeric string of 13 characters, which we call the ISCC -Component Code . See also: Base- ISCC Encoding reference code decode # Signature: decode(code: str) -> bytes the decode function accepts a 13- character ISCC -Component Code and returns the corresponding 9-byte ISCC -Component Digest . See also: Base- ISCC Decoding reference code Content Normalization # The ISCC standardizes some content normalization procedures to support reproducible and stable identifiers. Following the list of normalization functions that MUST be provided by a conforming implementation. text_trim # Signature: text_trim(text: str) -> str Trim text such that its UTF-8 encoded byte representation does not exceed 128-bytes each. Remove leading and trailing whitespace. See also: Text trimming reference code text_normalize # Signature: text_normalize(text: str, keep_ws: bool = False) -> str We define a text normalization function that is specific to our application. It takes text and an optional boolean keep_ws parameter as an input and returns normalized Unicode text for further algorithmic processing. The text_normalize function performs the following operations in the given order while each step works with the results of the previous operation: Decode to native Unicode if the text is a byte string Remove leading and trailing whitespace Transform text to lowercase Decompose the lower case text by applying Unicode Normalization Form D (NFD) . Filter out all characters that fall into the Unicode categories listed in the constant UNICODE_FILTER . Keep these control characters (Cc) that are commonly considered white-space: \\u0009 , # Horizontal Tab (TAB) \\u000A , # Linefeed (LF) \\u000D , # Carriage Return (CR) Keep or remove whitespace depending on the keep_ws parameter Re-Combine the text by applying Unicode Normalization Form KC (NFKC) . See also: Text normalization reference code image_normalize # Signature: image_normalize(img) -> List[List[int]] Accepts a file path, byte-stream or raw binary image data and MUST at least support JPEG, PNG, and GIF image formats. Normalize the image with the following steps: Convert the image to grayscale Resize the image to 32x32 pixels using bicubic interpolation Create a 32x32 two-dimensional array of 8-bit gray-scale values from the image data See also: Image normalization reference code Feature Hashing # The ISCC standardizes various feature hashing algorithms that reduce content features to a binary vector used as the body of the various Content-Code components. similarity_hash # Signature: similarity_hash(hash_digests: Sequence[ByteString]) -> bytes The similarity_hash function takes a sequence of hash digests that represent a set of features. Each of the digests MUST be of equal size. The function returns a new hash digest (raw 8-Bit bytes) of the same size. For each bit in the input-hashes calculate the number of hashes with that bit set and subtract the count of hashes where it is not set. For the output-hash set the same bit position to 0 if the count is negative or 1 if it is zero or positive. The resulting hash digest will retain similarity for similar sets of input hashes. See also [Charikar2002] . See also: Similarity hash reference code minimum_hash # Signature: minimum_hash(features: Iterable[int], n: int = 64) -> List[int] The minimum_hash function takes an arbitrary-sized set of 32-bit integer features and reduces it to a fixed size vector of n features such that it preserves similarity with other sets. It is based on the MinHash implementation of the datasketch library by Eric Zhu . See also: Minimum hash reference code image_hash # Signature: image_hash(pixels: List[List[int]]) -> bytes Perform a discrete cosine transform per row of input pixels. Perform a discrete cosine transform per column on the resulting matrix from step 2. Extract upper left 8x8 corner of the array from step 2 as a flat list. Calculate the median of the results from step 3. Create a 64-bit digest by iterating over the values of step 5 and setting a 1 - for values above median and 0 for values below or equal to the median. Return results from step 5. See also: Image hash reference code Content Defined Chunking # For shift resistant data chunking, the ISCC requires a custom chunking algorithm: data_chunks # Signature: data_chunks(data: stream) -> Iterator[bytes] The data_chunks function accepts a byte-stream and returns variable sized chunks. Chunk boundaries are determined by a gear based chunking algorithm based on [WenXia2016] . See also: CDC reference code Conformance Testing # An application that claims ISCC conformance MUST pass all required functions from the ISCC conformance test suite. The test suite is available as JSON data in our Github Repository . Test data is structured as follows: { \"<function_name>\" : { \"required\" : true , \"<test_name>\" : { \"inputs\" : [ \"<value1>\" , \"<value2>\" ], \"outputs\" : [ \"value1>\" , \"<value2>\" ] } } } The test suite also contains data for functions that are considered implementation details and MAY be skipped by other implementations. Optional tests are marked as \"required\": false . Outputs that are expected to be raw bytes are embedded as HEX encoded strings in JSON and prefixed with hex: to support automated decoding during implementation testing. Example Byte outputs in JSON test data: { \"data_chunks\": { \"test_001_cat_jpg\": { \"inputs\": [\"cat.jpg\"], \"outputs\": [\"hex:ffd8ffe1001845786966000049492a0008\", ...] } } } License # Copyright \u00a9 2016 - 2020 The Authors, Content Blockchain Project This work is licensed under a Creative Commons (CC BY-NC-SA 4.0) .","title":"Version 1.x"},{"location":"specification/#iscc-specification-v1x","text":"Last revised: 2022-10-10 16:40:22 Warning This document is out of date early draft and retained for historic reasons only. Please follow current development at https://ieps.iscc.codes","title":"ISCC - Specification v1.x"},{"location":"specification/#abstract","text":"The International Standard Content Code ( ISCC ) , is an open and decentralized digital media identifier. An ISCC can be created from digital content and its basic metadata by anybody who follows the procedures of the ISCC specification or by using open source software that supports ISCC creation conforming to the ISCC specification .","title":"Abstract"},{"location":"specification/#note-to-readers","text":"For public discussion of issues for this specification, please use the Github issue tracker: https://github.com/iscc/iscc-specs/issues . If you want to chat with developers, join us on Telegram at https://t.me/iscc_dev . You can find the latest version of this specification at http://iscc.codes/specification/ . Public review, discussion and contributions are welcome.","title":"Note to Readers"},{"location":"specification/#about-this-document","text":"Document Version While there is already a Version 1.0 spec, we are still expecting backward incompatible changes until Version 2.0 . Parts of this specification may become stable earlier. We will document this during minor releases. We encourage partners to follow development and test, implement, and give feedback based on the latest (this) version of the ISCC Specification. This document proposes an open and vendor neutral ISCC standard and describes the technical procedures to create and manage ISCC identifiers. The first version of this document resulted from a prototyping project by the Content Blockchain Project and received funding from the Google Digital News Initiative (DNI) . The content of this document results from a voluntary effort of the authors with an open and public consensus process.","title":"About this Document"},{"location":"specification/#conventions-and-terminology","text":"The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC 2119] .","title":"Conventions and Terminology"},{"location":"specification/#definitions","text":"Basic Metadata: Minimal set of ISCC -specific top-level metadata that applications SHOULD support. Bound Metadata: Metadata that is utilized during generation of the ISCC . A change of this bound metadata may therefore impact the derived ISCC .. Extended Metadata: Industry and application-specific metadata attached to an ISCC . Character: Throughout this specification a character is meant to be interpreted as one Unicode code point. This also means that due to the structure of Unicode a character is not necessarily a full glyph but might be a combining accent or similar. Digital Media Object: A blob of raw bytes with some media type specific encoding. Extended Metadata: Metadata that is not encoded within the ISCC Meta-Code but may be supplied together with the ISCC . Generic Media Type: A basic content type such as plain text in a normalized and generic ( UTF-8 ) encoding format. ISCC : International Standard Content Code ISCC Code : The printable text encoded representation of an ISCC ISCC Digest : The raw binary data of an ISCC","title":"Definitions"},{"location":"specification/#introduction","text":"An ISCC permanently identifies content at multiple levels of granularity . It is algorithmically generated from basic metadata and the contents of a digital media object. It is designed for being registered and stored on a public and decentralized blockchain. An ISCC for a media object can be created and registered by the content author, a publisher, a service provider or anybody else. By itself the ISCC and its basic registration on a blockchain does not make any statement or claim about authorship or ownership of the identified content.","title":"Introduction"},{"location":"specification/#iscc-structure","text":"A Fully Qualified ISCC Digest is a fixed size sequence of 36 bytes (288 bits) assembled from multiple sub-components. The Fully Qualified ISCC Code is a 52 character encoded printable string representation of a complete ISCC Digest . This is a high-level overview of the ISCC creation process:","title":"ISCC Structure"},{"location":"specification/#iscc-components","text":"The ISCC Digest is built from multiple self-describing 72-bit components: Components: Meta-Code Content-Code Data-Code Instance-Code Context: Intangible creation Content similarity Data similarity Data checksum Input: Metadata Extracted content Raw data Raw data Algorithms: Similarity Hash Type specific CDC , Minimum Hash Hash Tree Size: 72 bits 72 bits 72 bits 72 bits ISCC components MAY be used separately or in combination by applications for various purposes. Individual components MUST be presented as 13- character base58-iscc encoded strings to end users and MAY be prefixed with their component name. Single component ISCC -Code (13 characters) Meta-Code : CCDFPFc87MhdT Combinations of components MUST include the Meta-Code component and MUST be ordered as Meta-Code , Content-Code , Data-Code , and Instance-Code . Individual components MAY be skipped and SHOULD be separated with hyphens. A combination of components SHOULD be prefixed with \" ISCC \". Combination of ISCC -Code components ISCC : CCPktvj3dVoVa-CTPCWTpGPMaLZ-CDL6QsUZdZzog A Fully Qualified ISCC Code is an ordered sequence of Meta-Code, Content-Code, Data-Code, and Instance-Code codes. It SHOULD be prefixed with ISCC and MAY be separated by hyphens. Fully Qualified ISCC -Code (52 characters) ISCC : CCDFPFc87MhdTCTWAGYJ9HZGj1CDhydSjutScgECR4GZ8SW5a7uc Fully Qualified ISCC -Code with hyphens (55 characters) ISCC : CCDFPFc87MhdT-CTWAGYJ9HZGj1-CDhydSjutScgE-CR4GZ8SW5a7uc","title":"ISCC Components"},{"location":"specification/#component-types","text":"Each component has the same basic structure of a 1-byte header and a 8-byte body section. The 1-byte header of each component is subdivided into 2 nibbles (4 bits). The first nibble specifies the component type while the second nibble is component specific. The header only needs to be carried in the encoded representation. As similarity searches across different components are of little use, the type-information contained in the header of each component can be safely ignored after an ISCC has been decomposed and internally typed by an application.","title":"Component Types"},{"location":"specification/#list-of-component-headers","text":"Component Nibble-1 Nibble-2 Byte Code Meta-Code 0000 0000 - Reserved 0x00 CC Content-Code-Text 0001 0000 - Content Type Text 0x10 CT Content-Code-Text PCF 0001 0001 - Content Type Text + PCF 0x11 Ct Content-Code-Image 0001 0010 - Content Type Image 0x12 CY Content-Code-Image PCF 0001 0011 - Content Type Image + PCF 0x13 Ci Content-Code-Audio 0001 0100 - Content Type Audio 0x14 CA Content-Code-Audio PCF 0001 0101 - Content Type Audio + PCF 0x15 Ca Content-Code-Video 0001 0110 - Content Type Video 0x16 CV Content-Code-Video PCF 0001 0111 - Content Type Video + PCF 0x17 Cv Content-Code-Mixed 0001 1000 - Content Type Mixed 0x18 CM Content-Code Mixed PCF 0001 1001 - Content Type Mixed + PCF 0x19 Cm Data-Code 0010 0000 - Reserved 0x20 CD Instance-Code 0011 0000 - Reserved 0x30 CR The body section of each component is specific to the component and always 8-bytes and can thus be fit into a 64-bit integer for efficient data processing. The following sections give an overview of how the different components work and how they are generated.","title":"List of Component Headers"},{"location":"specification/#meta-code-component","text":"The Meta-Code component starts with a 1-byte header 00000000 . The first nibble 0000 indicates that this is a Meta-Code component type. The second nibble is reserved for future extended features of the Meta-Code. The Meta-Code body is built from a 64-bit similarity_hash over 4- character n-grams of the basic metadata of the content to be identified. The basic metadata supplied to the Meta-Code generating function is assumed to be UTF-8 encoded. Errors that occur during the decoding of such a byte string input to a native Unicode MUST terminate the process and must not be silenced. An ISCC generating application MUST provide a meta_id function that accepts minimal and generic metadata and returns a Base58- ISCC encoded Meta-Code component and trimmed metadata.","title":"Meta-Code Component"},{"location":"specification/#inputs-to-meta-code-function","text":"Name Type Required Description title text Yes The title of an intangible creation. extra text No An optional short statement that distinguishes this intangible creation from another one for forced Meta-Code uniqueness. (default: empty string) Note The basic metadata inputs are intentionally simple and generic. We abstain from more specific metadata for Meta-Code generation in favor of compatibility across industries. To support global clustering, it is RECOMMENDED to only supply the title field for Meta-Code generation. Imagine a creator input-field for metadata. Who would you list as the creators of a movie? The directors, writers, the main actors? Would you list some of them or if not how do you decide whom you will list. Global disambiguation of similar title data can be accomplished with the extra-field. Industry- and application-specific metadata requirements can be met by extended metadata .","title":"Inputs to Meta-Code function"},{"location":"specification/#generate-meta-code","text":"An ISCC generating application must follow these steps in the given order to produce a stable Meta-Code: Apply text_normalize separately to the title and extra inputs while keeping white space. Apply text_trim to the results of the previous step. The results of this step MUST be supplied as basic metadata for ISCC registration. Concatenate trimmed title and extra from using a space ( \\u0020 ) as a separator. Remove leading/trailing whitespace. Create a list of 4 character n-grams by sliding character -wise through the result of the previous step. Encode each n-gram from the previous step to an UTF-8 bytestring and calculate its xxHash64 digest. Apply similarity_hash to the list of digests from the previous step. Prepend the 1-byte component header ( 0x00 ) to the results of the previous step. Encode the resulting 9 byte sequence with encode Return encoded Meta-Code, trimmed title and trimmed extra data. See also: Meta-Code reference code Text trimming When trimming text be sure to trim the byte-length of the UTF-8 encoded version and not the number of characters. The trim point MUST be such that it does not cut into multi-byte characters. Characters might have different UTF-8 byte-length. For example \u00fc is 2-bytes, \u9a69 is 3-bytes and \ud841\udf0e is 4-bytes. So the trimmed version of a string with 128 \u9a69 -characters will result in a 42- character string with a 126-byte UTF-8 encoded length. This is necessary because the results of this operation will be stored as basic metadata with strict byte size limits on the blockchain. Automated Data-Ingestion Applications that perform automated data-ingestion SHOULD apply a customized preliminary normalization to title data tailored to the dataset. Depending on catalog data removing pairs of brackets [], (), {}, and text in between them or cutting all text after the first occurence of a semicolon (;) or colon (:) can vastly improve deduplication.","title":"Generate Meta-Code"},{"location":"specification/#dealing-with-meta-code-collisions","text":"Ideally we want multiple ISCCs that identify different manifestations of the same intangible creation to be automatically grouped by an identical leading Meta-Code component. We call such a natural grouping an intended component collision . Metadata, captured and edited by humans, is notoriously unreliable. By using normalization and a similarity hash on the metadata, we account for some of this variation while keeping the Meta-Code component somewhat stable. Auto-generated Meta-Codes components are expected to miss some intended collisions. An application SHOULD check for such missed intended component collisions before registering a new Meta-Code with the canonical registry of ISCCs by conducting a similarity search and asking for user feedback. But what about unintended component collisions ? Such collisions might happen because two different intangible creations have very similar or even identical metadata. But they might also happen by chance. With 2^56 possible Meta-Code components the probability of random collisions rises in an S-curved shape with the number of deployed ISCCs (see: Hash Collision Probabilities ). We should keep in mind that the Meta-Code component is only one part of a fully qualified ISCC Code . Unintended collisions of the Meta-Code component are generally deemed as acceptable and expected . If for any reason an application wants to avoid unintended collisions with pre-existing Meta-Code components, it may use the extra -field. An application MUST first generate a Meta-Code without asking the user for input to the extra -field and then first check for collisions with the canonical registry of ISCCs. After it finds a collision with a pre-existing Meta-Code it may display the metadata of the colliding entry and interact with the user to determine if it is an unintended collision. Only if the user indicates an unintended collision, may the application ask for a disambiguation that is then added as an amendment to the metadata via the extra -field to create a different Meta-Code component. The application may repeat the pre-existence check until it finds no collision or a user intended collision. The application MUST NOT supply auto-generated input to the extra -field. It is our opinion that the concept of intended collisions of Meta-Code components is a useful concept and a net positive. But one must know that this characteristic also has its pitfalls. It is not an attempt to provide an unambiguous - agreed upon - definition of \"identical intangible creations\" .","title":"Dealing with Meta-Code collisions"},{"location":"specification/#content-code-component","text":"The Content-Code component has multiple subtypes. The subtypes correspond with the Generic Media Types ( GMT ) . A fully qualified ISCC can only have one Content-Code component of one specific GMT , but there may be multiple ISCCs with different Content-Code types per digital media object. A Content-Code is generated in two broad steps. In the first step, we extract and convert content from a rich media type to a normalized GMT . In the second step, we use a GMT -specific process to generate the Content-Code component of an ISCC .","title":"Content-Code Component"},{"location":"specification/#generic-media-types","text":"The Content-Code type is signaled by the first 3 bits of the second nibble of the first byte of the Content-Code: Content-Code Type Nibble 2 Bits 0-3 Description text 000 Generated from extracted and normalized plain-text image 001 Generated from normalized grayscale pixel data audio 010 To be defined in a later version of the specification video 011 To be defined in a later version of the specification mixed 100 Generated from multiple Content-Codes 101, 110, 111 Reserved for future versions of specification","title":"Generic Media Types"},{"location":"specification/#content-code-text","text":"The Content-Code-Text is built from the extracted plain-text content of an encoded media object. To build a stable Content-Code-Text the plain-text content must first be extracted from the digital media object. It should be extracted in a way that is reproducible. There are many text document formats out in the wild and extracting plain-text from all of them is anything but a trivial task. While text-extraction is out of scope for this specification it is RECOMMENDED, that plain-text content SHOULD be extracted with the open-source Apache Tika v1.23 toolkit, if a generic reproducibility of the Content-Code-Text component is desired. An ISCC generating application MUST provide a content_id(text, partial=False) function that accepts UTF-8 encoded plain text and a boolean, indicating the partial content flag as input and returns a Content-Code with GMT type text . The procedure to create a Content-Code-Text is: Apply text_normalize to the text input while removing white-space. Create character -wise n-grams of length 13 from the normalized text. Create a list of 32-bit unsigned integer features by applying xxHash32 to the results of the previous step. Apply minimum_hash to the list of features from the previous step with n=64. Collect the least significant bits from the 64 MinHash features from the previous step. Create a 64-bit digest from the collected bits. Prepend the 1-byte component header ( 0x10 full content or 0x11 partial content). Encode and return the resulting 9-byte sequence with encode . See also: Content-Code-Text reference code","title":"Content-Code-Text"},{"location":"specification/#content-code-image","text":"For the Content-Code-Image we are opting for a DCT-based perceptual image-hash instead of a more sophisticated key-point detection based method. In view of the generic deployability of the ISCC we chose an algorithm that has moderate computation requirements and is easy to implement while still being robust against common image manipulations. An ISCC generating application MUST provide a content_id_image(image, partial=False) function that accepts a local file path to an image and returns a Content-Code with GMT type image . The procedure to create a Content-Code-Image is as follows: Apply image_normalize to receive a two-dimensional array of gray-scale pixel data. Apply image_hash to the results of the previous step. Prepend the 1-byte component header ( 0x12 full content or 0x13 partial content) to results of the previous step. Encode and return the resulting 9-byte sequence with encode See also: Content-Code-Image reference code Image Data Input The content_id_image function may optionally accept the raw byte data of an encoded image or an internal native image object as input for convenience. JPEG Decoding Decoding of JPEG images is non deterministic. Different image processing libraries may yield diverging pixel data and result in different Image-IDs. The reference implementation uses the built-in decoder of the Python Pillow imaging library. Future versions of the ISCC specification may define a custom deterministic JPEG decoding procedure.","title":"Content-Code-Image"},{"location":"specification/#content-code-mixed","text":"The Content-Code-Mixed aggregates multiple Content-Codes of the same or different types. It may be used for digital media objects that embed multiples types of media or for collections of contents of the same type. First, we have to collect contents from the mixed media object or content collection and generate Content-Codes for each item. An ISCC conforming application must provide a content_id_mixed function that takes a list of Content-Code Codes as input and returns a Content-Code-Mixed. Follow these steps to create a Content-Code-Mixed: Signature: conent_id_mixed(cids: List[str], partial: bool=False) -> str Decode the list of Content-Codes. Extract the first 8-bytes from each digest ( Note : this includes the header part of the Content-Codes). Apply similarity_hash to the list of digests from step 2. Prepend the 1-byte component header( 0x18 full content or 0x19 partial content) Apply encode to the result of step 5 and return the result. See also: Content-Code-Mixed reference code","title":"Content-Code-Mixed"},{"location":"specification/#partial-content-flag-pcf","text":"The last bit of the header byte of the Content-Code is the \"Partial Content Flag\". It designates if the Content-Code applies to the full content, or just some part of it. The PCF MUST be set as a 0 -bit ( full GMT -specific content ) by default. Setting the PCF to 1 enables applications to create multiple linked ISCCs of partial extracts of a content collection. The exact semantics of partial content are outside of the scope of this specification. Applications that plan to support partial Content-Codes MUST define their semantics. PCF Linking Example Let's assume we have a single newspaper issue \"The Times - 03 Jan 2009\". You would generate one Meta-Code component with the title \"The Times\" and extra \"03 Jan 2009\". The resulting Meta-Code component will be the grouping prefix in this scenario. We use a Content-Code-Mixed with PCF 0 (not partial) for the ISCC of the newspaper issue. We generate Data-Code and Instance-Code from the print PDF of the newspaper issue. To create an ISCC for a single extracted image that should convey context with the newspaper issue, we reuse the Meta-Code of the newspaper issue and create a Content-Code-Image with PCF 1 (partial to the newspaper issue). For the Data-Code or Instance-Code of the image, we are free to choose if we reuse those of the newspaper issue or create separate ones. The former would express strong specialization of the image to the newspaper issue (not likely to be useful out of context). The latter would create a stronger link to an eventual standalone ISCC of the image. Note that the ISCC of the individual image keeps links in both ways: Image is linked to the newspaper issue by identical Meta-Code component Image is linked to the standalone version of the image by identical Content-Code-Image body This is just one example that illustrates the flexibility that the PCF -Flag provides in concert with a grouping Meta-Code. With great flexibility comes great danger of complexity. Applications SHOULD do careful planning before using the PCF -Flag with internally defined semantics.","title":"Partial Content Flag (PCF)"},{"location":"specification/#data-code-component","text":"For the Data-Code that encodes data similarity we use a content defined chunking algorithm that provides some shift resistance and calculate the MinHash from those chunks. To accommodate for small files, the first 100 chunks have a ~140-byte size target while the remaining chunks target ~ 6kb in size. The Data-Code is built from the raw encoded data of the content to be identified. An ISCC generating application MUST provide a data_id function that accepts the raw encoded data as input.","title":"Data-Code Component"},{"location":"specification/#generate-data-code","text":"Apply data_chunks to the raw encoded content data. For each chunk, calculate the xxHash32 integer hash. Apply minimum_hash to the resulting list of 32-bit unsigned integers with n=64. Collect the least significant bits from the 64 MinHash features. Create a 64-bit digest from the collected bits. Prepend the 1-byte component header (eg. 0x20). Apply encode to the result of step 6 and return the result. See also: Data-Code reference code","title":"Generate Data-Code"},{"location":"specification/#instance-code-component","text":"The Instance-Code is built from the raw data of the media object to be identified and serves as checksum for the media object. The raw data of the media object is split into 64-kB data-chunks. Then we build a hash-tree from those chunks and use the truncated tophash (Merkle root) as component-body of the Instance-Code. To guard against length-extension attacks and second preimage attacks, we use double sha256 for hashing. We also prefix the hash input data with a 0x00 -byte for the leaf nodes hashes and with a 0x01 -byte for the internal node hashes. While the Instance-Code itself is a non-cryptographic checksum, the full tophash may be supplied in the extended metadata of an ISCC secure integrity verification is required. An ISCC generating application MUST provide a instance_id function that accepts the raw data file as input and returns an encoded Instance-Code and a full hex-encoded 256-bit tophash .","title":"Instance-Code Component"},{"location":"specification/#generate-instance-code","text":"Split the raw bytes of the encoded media object into 64-kB chunks. For each chunk, calculate the sha256d of the concatenation of a 0x00 -byte and the chunk bytes. We call the resulting values leaf node hashes ( LNH ). Calculate the next level of the hash tree by applying sha256d to the concatenation of a 0x01 -byte and adjacent pairs of LNH values. If the length of the list of LNH values is uneven, concatenate the last LNH value with itself. We call the resulting values internal node hashes ( INH ). Recursively apply 0x01 -prefixed pair-wise hashing to the results of the last step until the process yields only one hash value. We call this value the tophash . Trim the resulting tophash to the first 8 bytes. Prepend the 1-byte component header (e.g. 0x30 ). Encode resulting 9-byte sequence with encode to an Instance-Code Code Hex-Encode the tophash Return the Instance-Code and the hex-encoded tophash See also: Instance-Code reference code Applications may carry, store, and process the leaf node hashes for advanced streaming data identification or partial data integrity verification.","title":"Generate Instance-Code"},{"location":"specification/#iscc-metadata","text":"As a generic content identifier, the ISCC makes minimal assumptions about metadata that must or should be supplied together with an ISCC . The RECOMMENDED data-interchange format for ISCC metadata is JSON . We distinguish between Basic Metadata and Extended Metadata :","title":"ISCC Metadata"},{"location":"specification/#basic-metadata","text":"Basic metadata for an ISCC is metadata that is explicitly defined by this specification. The following table enumerates basic metadata fields for the top-level of the JSON metadata object: Name Type Required Bound Description version integer No No Version of ISCC Specification. Assumed to be 1 if omitted. title text Yes Yes The title of an intangible creation identified by the ISCC . The normalized and trimmed UTF-8 encoded text MUST not exceed 128 bytes. The result of processing title and extra data with the meta_id function MUST match the Meta-Code component of the ISCC . extra text No Yes An optional short statement that distinguishes this intangible creation from another one for Meta-Code uniqueness. tophash text (hex) No No The full hex-encoded tophash (Merkle root) returned by the instance_id function. meta array No No A list of one or more extended metadata entries. Must include at least one entry if specified. Attention Bound metadata impacts the ISCC Code (Meta-Code) and cannot be changed afterwards. Depending on adoption and real world use, future versions of this specification may define new basic metadata fields. Applications MAY add custom fields at the top level of the JSON object, but MUST prefix those fields with an underscore to avoid collisions with future extensions of this specification.","title":"Basic Metadata"},{"location":"specification/#extended-metadata","text":"Extended metadata for an ISCC is metadata that is not explicitly defined by this specification. All such metadata SHOULD be supplied as JSON objects within the top-level meta -array field. This allows for a flexible and extendable way to supply additional industry specific metadata about the identified content. Extended metadata entries MUST be wrapped in JSON object of the following structure: Name Description schema The schema -field may indicate a well-known metadata schema (such as Dublin Core, IPTC, ID3v2, ONIX) that is used. RECOMMENDED schema : \" schema.org \" mediatype The mediatype -field specifies an IANA Media Type . RECOMMENDED mediatype : \"application/ld+json\" url An URL that is expected to host the metadata with the indicated schema and mediatype . This field is only required if the data -field is omitted. data The data -field holds the metadata conforming to the indicated schema and mediatype. It is only required if the url field is omitted.","title":"Extended Metadata"},{"location":"specification/#iscc-registration","text":"The ISCC is a decentralized identifier. ISCCs can be generated for content by anybody who has access to the content. Because of the clustering properties of its components, the ISCC provides utility in data interchange and de-duplication scenarios even without a global registry. There is no central authority for the registration of ISCC codes or certification of content authorship. As an open system, the ISCC allows any person or organization to offer ISCC registration services as they see fit and without the need to ask anyone for permission. This also presumes that no person or organization may claim exclusive authority about ISCC registration.","title":"ISCC Registration"},{"location":"specification/#blockchain-registry","text":"To properly address the questions of identifier uniqueness, ownership and authentication within the ISCC Standard, the assignment of a set of canonical blockchain is a requirement. The distributed nature of blockchains are a perfect fit for long-term persistent identifier registration and resolver services. The assignment of a set of canonical blockchains is NOT YET part of this specification. Because this decision is of such vital importance, we suggest waiting for further feedback and additional community involvement before we address these questions either in an updated version of this specification or in a separate specification. Our recommendation to the community is to agree on a set of decentralized, open, and public blockchains that have specific support for registry-services. This would maximize the value for all participants in the ecosystem. Governance and protocol related questions are being worked on by many projects. See also: ISCC -Stream specification .","title":"Blockchain Registry"},{"location":"specification/#iscc-embedding","text":"Embedding ISCC codes into content is only RECOMMENDED if it does not create a side effect. We call it a side effect if embedding an ISCC code changes the content to such an extent, that it yields a different ISCC code. Side effects will depend on the combination of ISCC components that are to be embedded. A Meta-Code can always be embedded without side effects because it does not depend on the content itself. Content-Code and Data-Code may not change if embedded in larger media objects. Instance-Codes cannot easily be embedded as they will inevitably have a side effect on the post-embedding Instance-Code without special processing. Applications MAY embed ISCC codes that have side effects if they specify a procedure by which the embedded ISCC codes can be stripped in such a way that the stripped content will yield the original embedded ISCC codes. ISCC Embedding We can embed the following combination of components from the markdown version of this document into the document itself because adding or removing them has no side effect: ISCC : CCDbMYw6NfC8a-CTtW9UFozcmBJ-CDYJsRdBNAERM","title":"ISCC Embedding"},{"location":"specification/#iscc-uri-scheme","text":"Provisional Section The ISCC URI Scheme and link-resolver details ultimately depend on identifier registration, ownership, uniqueness and governance related decisions which are not yet part of this specification. See also: Blockchain Registry . The purpose of the ISCC URI scheme based on RFC 3986 is to enable users to discover information like metadata or license offerings from an ISCC marked content by clicking a link on a webpage or by scanning a QR-Code. The scheme name is iscc . The path component MUST be a fully qualified ISCC Code without hyphens. An optional stream query key MAY indicate the blockchain stream information source. If the stream query key is omitted, applications SHOULD return information from the open ISCC Stream . The scheme name component (\"iscc:\") is case-insensitive. Applications MUST accept any combination of uppercase and lowercase letters in the scheme name. All other URI components are case-sensitive. Applications MAY register themselves as a handler for the \"iscc:\" URI scheme if no other handler is already registered. If another handler is already registered, an application MAY ask the user to change it on the first run of the application.","title":"ISCC URI Scheme"},{"location":"specification/#uri-syntax","text":"<foo> means placeholder, [bar] means optional. iscc:<fq-iscc-code>[?stream=<name>]","title":"URI Syntax"},{"location":"specification/#uri-example","text":"iscc:11TcMGvUSzqoM1CqVA3ykFawyh1R1sH4Bz8A1of1d2Ju4VjWt26S?stream=smart-license","title":"URI Example"},{"location":"specification/#procedures-algorithms","text":"","title":"Procedures &amp; Algorithms"},{"location":"specification/#base58-iscc","text":"The ISCC uses a custom per-component data encoding similar to the zbase62 encoding by Zooko Wilcox-O'Hearn but with a 58- character symbol table. The encoding does not require padding and will always yield component codes of 13 characters length for 72-bit component digests. The predictable size of the encoding is a property that allows for easy composition and decomposition of components without having to rely on a delimiter (hyphen) in the ISCC code representation. Colliding body segments of the digest are preserved by encoding the header and body separately. The ASCII symbol table also minimizes transcription and OCR errors by omitting the easily confused characters 'O', '0', 'I', 'l' and is shuffled to generate human readable component headers. Symbol table SYMBOLS = \"C23456789rB1ZEFGTtYiAaVvMmHUPWXKDNbcdefghLjkSnopRqsJuQwxyz\"","title":"Base58-ISCC"},{"location":"specification/#encode","text":"Signature: encode(digest: bytes) -> str The encode function accepts a 9-byte ISCC Component Digest and returns the Base58- ISCC encoded alphanumeric string of 13 characters, which we call the ISCC -Component Code . See also: Base- ISCC Encoding reference code","title":"encode"},{"location":"specification/#decode","text":"Signature: decode(code: str) -> bytes the decode function accepts a 13- character ISCC -Component Code and returns the corresponding 9-byte ISCC -Component Digest . See also: Base- ISCC Decoding reference code","title":"decode"},{"location":"specification/#content-normalization","text":"The ISCC standardizes some content normalization procedures to support reproducible and stable identifiers. Following the list of normalization functions that MUST be provided by a conforming implementation.","title":"Content Normalization"},{"location":"specification/#text_trim","text":"Signature: text_trim(text: str) -> str Trim text such that its UTF-8 encoded byte representation does not exceed 128-bytes each. Remove leading and trailing whitespace. See also: Text trimming reference code","title":"text_trim"},{"location":"specification/#text_normalize","text":"Signature: text_normalize(text: str, keep_ws: bool = False) -> str We define a text normalization function that is specific to our application. It takes text and an optional boolean keep_ws parameter as an input and returns normalized Unicode text for further algorithmic processing. The text_normalize function performs the following operations in the given order while each step works with the results of the previous operation: Decode to native Unicode if the text is a byte string Remove leading and trailing whitespace Transform text to lowercase Decompose the lower case text by applying Unicode Normalization Form D (NFD) . Filter out all characters that fall into the Unicode categories listed in the constant UNICODE_FILTER . Keep these control characters (Cc) that are commonly considered white-space: \\u0009 , # Horizontal Tab (TAB) \\u000A , # Linefeed (LF) \\u000D , # Carriage Return (CR) Keep or remove whitespace depending on the keep_ws parameter Re-Combine the text by applying Unicode Normalization Form KC (NFKC) . See also: Text normalization reference code","title":"text_normalize"},{"location":"specification/#image_normalize","text":"Signature: image_normalize(img) -> List[List[int]] Accepts a file path, byte-stream or raw binary image data and MUST at least support JPEG, PNG, and GIF image formats. Normalize the image with the following steps: Convert the image to grayscale Resize the image to 32x32 pixels using bicubic interpolation Create a 32x32 two-dimensional array of 8-bit gray-scale values from the image data See also: Image normalization reference code","title":"image_normalize"},{"location":"specification/#feature-hashing","text":"The ISCC standardizes various feature hashing algorithms that reduce content features to a binary vector used as the body of the various Content-Code components.","title":"Feature Hashing"},{"location":"specification/#similarity_hash","text":"Signature: similarity_hash(hash_digests: Sequence[ByteString]) -> bytes The similarity_hash function takes a sequence of hash digests that represent a set of features. Each of the digests MUST be of equal size. The function returns a new hash digest (raw 8-Bit bytes) of the same size. For each bit in the input-hashes calculate the number of hashes with that bit set and subtract the count of hashes where it is not set. For the output-hash set the same bit position to 0 if the count is negative or 1 if it is zero or positive. The resulting hash digest will retain similarity for similar sets of input hashes. See also [Charikar2002] . See also: Similarity hash reference code","title":"similarity_hash"},{"location":"specification/#minimum_hash","text":"Signature: minimum_hash(features: Iterable[int], n: int = 64) -> List[int] The minimum_hash function takes an arbitrary-sized set of 32-bit integer features and reduces it to a fixed size vector of n features such that it preserves similarity with other sets. It is based on the MinHash implementation of the datasketch library by Eric Zhu . See also: Minimum hash reference code","title":"minimum_hash"},{"location":"specification/#image_hash","text":"Signature: image_hash(pixels: List[List[int]]) -> bytes Perform a discrete cosine transform per row of input pixels. Perform a discrete cosine transform per column on the resulting matrix from step 2. Extract upper left 8x8 corner of the array from step 2 as a flat list. Calculate the median of the results from step 3. Create a 64-bit digest by iterating over the values of step 5 and setting a 1 - for values above median and 0 for values below or equal to the median. Return results from step 5. See also: Image hash reference code","title":"image_hash"},{"location":"specification/#content-defined-chunking","text":"For shift resistant data chunking, the ISCC requires a custom chunking algorithm:","title":"Content Defined Chunking"},{"location":"specification/#data_chunks","text":"Signature: data_chunks(data: stream) -> Iterator[bytes] The data_chunks function accepts a byte-stream and returns variable sized chunks. Chunk boundaries are determined by a gear based chunking algorithm based on [WenXia2016] . See also: CDC reference code","title":"data_chunks"},{"location":"specification/#conformance-testing","text":"An application that claims ISCC conformance MUST pass all required functions from the ISCC conformance test suite. The test suite is available as JSON data in our Github Repository . Test data is structured as follows: { \"<function_name>\" : { \"required\" : true , \"<test_name>\" : { \"inputs\" : [ \"<value1>\" , \"<value2>\" ], \"outputs\" : [ \"value1>\" , \"<value2>\" ] } } } The test suite also contains data for functions that are considered implementation details and MAY be skipped by other implementations. Optional tests are marked as \"required\": false . Outputs that are expected to be raw bytes are embedded as HEX encoded strings in JSON and prefixed with hex: to support automated decoding during implementation testing. Example Byte outputs in JSON test data: { \"data_chunks\": { \"test_001_cat_jpg\": { \"inputs\": [\"cat.jpg\"], \"outputs\": [\"hex:ffd8ffe1001845786966000049492a0008\", ...] } } }","title":"Conformance Testing"},{"location":"specification/#license","text":"Copyright \u00a9 2016 - 2020 The Authors, Content Blockchain Project This work is licensed under a Creative Commons (CC BY-NC-SA 4.0) .","title":"License"}]}